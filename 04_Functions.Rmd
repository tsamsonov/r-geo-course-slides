---
title: "Техники программирования"
subtitle: "Визуализация и анализ географических данных на языке R"
author: "Тимофей Самсонов"
institute: "МГУ имени Ломоносова, Географический факультет"
date: "`r Sys.Date()`"
output:
  xaringan::moon_reader:
    css: [default, "custom.css"]
    lib_dir: libs
    nature:
      highlightLines: true
      countIncrementalSlides: false
      ratio: 16:9
---

# Функции

```{r setup, echo = FALSE, purl = FALSE, cache = FALSE, include=FALSE}
knitr::opts_knit$set(global.par = TRUE)
knitr::opts_chunk$set(warning=FALSE, collapse = TRUE)
```

Функции в R можно использовать для структурирования кода на логически завершенные, автономные фрагменты кода, каждый из которых выполняет конкретную задачу. Синтаксис функции выглядит следующим образом:
```{r eval=FALSE}
functionName = function(parameter1, parameter2, ...){
  ...
  return(result)
  ...
  last_value = ...
}
```

- Если не указано иное, то будет возвращен результат вычисления последнего выражения, выполненного внутри функции (`last_value`  в примере выше)
<br><br>
- Результат можно вернуть принудительно в любом месте функции, передав его в выражение `return()`.

---

# Функции

Пример — вычисление расстояния по координатам:

```{r}
x = 10 * rnorm(4)
y = 10 * rnorm(4)

distance = function(x1, y1, x2, y2) {
  sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2)
}

d12 = distance(x[1], y[1], x[2], y[2])
d23 = distance(x[2], y[2], x[3], y[3])
d31 = distance(x[3], y[3], x[4], y[4])

cat(d12, d23, d31)
```

---

# Функции

Расстояние для матрицы координат:

```{r}
distances = function(xy) {
  n = nrow(xy)
  distance(xy[1:(n-1), 'x'], xy[1:(n-1), 'y'], #<<
           xy[2:n, 'x'],     xy[2:n, 'y']) #<<
}

(coords = cbind(x, y))

distances(coords)
```

---

# Функции

Длина линии:
```{r}
line_length = function(xy) {
  sum(distances(xy)) #<<
}

line_length(coords)
```

Полученные функции образуют иерархию вызовов:
<br><br>
`line_length() -> distances() -> distance()`

---

# Функции

Несколько объектов можно вернуть через список:
```{r}
line_params = function(xy) {
  n = nrow(xy)
  
  l = line_length(xy)
  s = l / distance(xy[1, 'x'], xy[1, 'y'], xy[n, 'x'], xy[n, 'y']) 
  
  list(length = l, sinuosity = s)#<<
}

result = line_params(coords)
result$length
result$sinuosity
```

---

# Функционалы

__Функционал__ — это функция, которая принимает на вход другую функцию и возвращает вектор. Функционалы используются в качестве замены цикла для быстрой обработки последовательности элементов.
<br><br>

 Функция    | Назначение  
------------|--------------------------------------------------------------
`apply()`   | применить функцию ко всем строкам или столбцам матрицы
`lapply()`  | применить функцию к каждому компоненту вектора или списка и получить результат также в виде списка (_l — list_)
`sapply()`  | применить функцию к каждому компоненту вектора или списка и получить результат в виде вектора (_s — simplify_)
`vapply()`  | аналогична vapply, но требует явного задания типа данных возвращаемого вектора, за счет чего работает быстрее (_v — velocity_)

---

# Функционалы

Базовая функция `apply(X, MARGIN, FUN, ...)` имеет следующие аргументы:

- `X` — массив любой размерности (включая вектор)


- `MARGIN` — измерения по которым необходимо вести вычисления. Для матрицы `1` означает строку, `2` означает столбец, `c(1, 2)` будет означать, что вычисления производятся по всем комбинациям строк и столбцов



- `FUN` — функция, которая будет применяться к каждому элементу указанных измерений


- `...` — список аргументов, которые надо передать в функцию `FUN` (в этом случае массив должен передаваться обязательно в первый аргумент)

---

# Функционалы

```{r, collapse=TRUE}
library(readxl)
library(dplyr)
(df = read_excel("../r-geo-course/data/sevzap.xlsx", col_types = c('text', rep('numeric', 17))))
```

---

# Функционалы

Максимальное значение каждой переменной:
```{r}
apply(df[-1], 2, max)
```

Что равносильно вызову sapply:
```{r}
sapply(df[-1], max)
```

---

# Функционалы

.pull-left[
Нормализация переменных:

```{r}
lapply(df[-1], function(X) { 
  round(X/mean(X,na.rm = TRUE),2) 
}) |> as_tibble()
```
]

.pull-right[
Начиная с R 4.1 можно анонимные функции можно создавать через синтаксис `\(...){...}`

```{r}
lapply(df[-1], \(X) { #<<
  round(X/mean(X,na.rm = TRUE),2) 
}) |> as_tibble()
```
]

---

# Функционалы

Если функция большая, то ее целесообразно создать заранее:

```{r}
normalize = function(X) {
  if (is.numeric(X)) 
    round(X / mean(X, na.rm = TRUE), 2) 
  else X
}

df |> lapply(normalize) |> as_tibble()
```

---

# Функционалы

Пакет __purrr__ содержит более широкий спектр функционалов. Есть и аналоги базовых функционалов:

- `map()` возвращает список.
- `map_lgl()` возвращает вектор логических значений.
- `map_int()` возвращает вектор целочисленных значений.
- `map_dbl()` возвращает вектор чисел с плавающей точкой.
- `map_chr()` возвращает вектор строк.

```{r}
library(purrr)
map_dbl(df[-1], max)
```