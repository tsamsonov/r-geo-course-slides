<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Основы графики</title>
    <meta charset="utf-8" />
    <meta name="author" content="Тимофей Самсонов" />
    <meta name="date" content="2021-10-05" />
    <script src="libs/header-attrs-2.11/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="custom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Основы графики
## Визуализация и анализ географических данных на языке R
### Тимофей Самсонов
### МГУ имени Ломоносова, Географический факультет
### 2021-10-05

---




# Исходные данные

__Исходные данные:__ экспорт/импорт продукции по регионам России (млн долл. США):


```
## # A tibble: 12 x 5
##    Регион               ПродЭкспорт ПродИмпорт ТЭКЭкспорт ТЭКИмпорт
##    &lt;chr&gt;                      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;     &lt;dbl&gt;
##  1 Белгородская область       222.       614.        64.7      24.1
##  2 Брянская область            28.5      650.         5        20.5
##  3 Владимирская область       178.       454.         0.9      16.7
##  4 Воронежская область        374.       182.        38.9      38  
##  5 Ивановская область           3.1      106.         0.1       0.1
##  6 Калужская область           20.9      185.        14        57.9
##  7 Костромская область          0.7        6.8        0        NA  
##  8 Курская область            140.       219.        NA        17.7
##  9 Липецкая область           162.       301         49.8     108. 
## 10 Московская область         774.      3830.      1400.      156. 
## 11 Орловская область           46        117.        NA        12.1
## 12 Рязанская область            7.9      101.        33.7      23.9
```

---

# Диаграммы рассеяния

.pull-left[

Диаграмма расеяния показывает соотношение двух переменных на точечном графике
.code-small[

```r
plot(sub$МетЭкспорт, 
     sub$МетИмпорт,
     col="red", 
     xlab="Экспорт, млн. долл. США", 
     ylab = "Импорт, млн. долл. США", 
     main = "Экспорт/импорт металлов и 
     изделий из них по субъектам РФ")
```
]]

.pull-right[
![](05_Graphics_files/figure-html/select-out-1.png)&lt;!-- --&gt;
]


---

# Диаграммы рассеяния

.pull-left[
Если показатели однородны, то целесообразно установить одинаковый масштаб по осям через параметр `asp`:
.code-small[

```r
plot(sub$МетЭкспорт, 
     sub$МетИмпорт, 
     col="red", 
     xlab="Экспорт, млн. долл. США", 
     ylab = "Импорт, млн. долл. США", 
     main = "Экспорт/импорт металлов и 
     изделий из них по субъектам РФ", 
*    asp = 1)
```
]
]

.pull-right[
![](05_Graphics_files/figure-html/select-out-1.png)&lt;!-- --&gt;
]


---

# Диаграммы рассеяния

_Размер и тип значка_ можно изменить, используя параметры `pch =` и `cex =`:

.left-60[
.code-small[

```r
plot(sub$МетЭкспорт, sub$МетИмпорт, col="red", xlab="Экспорт, млн. долл. США", ylab = "Импорт, млн. долл. США", main = "Экспорт/импорт металлов и изделий из них по субъектам РФ", asp = 1,
*    pch = 18, cex = 4)
```

&lt;img src="05_Graphics_files/figure-html/unnamed-chunk-2-1.png" width="60%" /&gt;
]
]

.right-40[
&lt;img src="img/pch.jpg" width="65%" /&gt;
]


---

# Линейные графики

Данные по объему сброса загрязненных сточных вод по морям России (млрд куб. м):

```
## ℹ Using "','" as decimal and "'.'" as grouping mark. Use `read_delim()` for more control.
## # A tibble: 22 x 9
##      Год Всего Балтийское Черное Азовское Каспийское Карское Белое Прочие
##    &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
##  1  1993  27.2        2.5    0.4      4.3       12.1     5.3   1      1.6
##  2  1994  24.6        2.3    0.4      3.2       11       5     0.9    1.8
##  3  1995  24.5        2.3    0.4      3.5       10.4     5.2   0.9    1.8
##  4  1996  22.4        2.2    0.3      3.1        9.8     4.7   0.8    1.5
##  5  1997  23          2.2    0.3      3.8        9.8     4.4   0.8    1.7
##  6  1998  22          2.2    0.3      3.2        9.5     4.2   0.8    1.8
##  7  1999  20.7        2.2    0.3      2.5        9.1     4.1   0.8    1.7
##  8  2000  20.3        2.2    0.3      2          9.2     4.2   0.9    1.5
##  9  2001  19.8        2.1    0.3      1.9        8.9     4.2   0.9    1.5
## 10  2002  19.8        2      0.2      2          9.2     4.1   0.8    1.5
## # … with 12 more rows
```

---

# Линейные графики

Тип графика определяется через параметр `type`

.pull-left[
.code-small[

```r
plot(tab$Год, tab$Каспийское, type="l")
```

&lt;img src="05_Graphics_files/figure-html/unnamed-chunk-5-1.png" width="80%" /&gt;
]
]

.pull-right[
.code-small[

```r
plot(tab$Год, tab$Каспийское, type="b")
```

&lt;img src="05_Graphics_files/figure-html/unnamed-chunk-6-1.png" width="80%" /&gt;
]
]

---

# Линейные графики

Толщина и тип устанавливаются через параметры `lwd` и `lty`:

.pull-left[
.code-small[

```r
plot(tab$Год, tab$Каспийское, 
     type="l", lwd = 3, lty = 1)
```

&lt;img src="05_Graphics_files/figure-html/unnamed-chunk-7-1.png" width="80%" /&gt;
]
]

.pull-right[
.code-small[

```r
plot(tab$Год, tab$Каспийское, 
     type="l", lwd = 6, lty = 3)
```

&lt;img src="05_Graphics_files/figure-html/unnamed-chunk-8-1.png" width="80%" /&gt;
]
]

---

# Совмещение графиков

.pull-left[

```r
plot(tab$Год, 
     tab$Азовское, 
     pch=20, 
     type="o", 
     col="red3")

# Добавим теперь на существующий 
# график новый ряд данных,  
# используя points() и lines():

points(tab$Год, tab$Карское,
       pch=20, col="forestgreen")

lines(tab$Год, tab$Карское,
      pch=20, col="forestgreen")
```
]

.pull-right[
![](05_Graphics_files/figure-html/combine-out-1.png)&lt;!-- --&gt;
]

---

# Совмещение графиков

Заранее вычислить диапазон по осям можно через `range`

.pull-left[
.code-small[

```r
*xrange = range(tab$Год)
*yrange = range(tab$Каспийское,
*              tab$Карское,
*              tab$Азовское)
# n означает, что ряд данных 
# рисоваться не будет
*plot(xrange, yrange,
*    type = "n",
     main="Объем сброса загрязненных сточных вод", xlab="Год", ylab="млрд.куб.м", ) 

points(tab$Год, tab$Азовское, pch=20, col="red3")
lines(tab$Год, tab$Азовское, pch=20, col="red3")

points(tab$Год, tab$Карское, pch=20, col="forestgreen")
lines(tab$Год, tab$Карское, pch=20, col="forestgreen")

points(tab$Год, tab$Каспийское, pch=20, col="steelblue")
lines(tab$Год, tab$Каспийское, pch=20, col="steelblue")
```
]
]

.pull-right[
![](05_Graphics_files/figure-html/combine2-out-1.png)&lt;!-- --&gt;
]

---

# Функциональные параметры

Графические параметры могут быть _функцией_ данных:

.pull-left[
.code-small[

```r
plot(okr$МетЭкспорт, 
     okr$МетИмпорт, 
     col=rgb(1,0,0,0.5), 
     xlab="Экспорт, млн. долл. США", 
     ylab = "Импорт, млн. долл. США", 
     main = "Экспорт/импорт металлов и 
     изделий из них по ФО РФ (2013 г.)", 
     asp = 1,
     pch = 20, 
*    cex = 4 * log(2 + sub$МетИмпорт/
*                  sub$МетЭкспорт))
```
]
]

.pull-right[
![](05_Graphics_files/figure-html/funcpar-out-1.png)&lt;!-- --&gt;
]

---

# Гистограммы

.large[Гистограммы распределения строятся с помощью функции `hist()`.]

.pull-left[
&lt;br&gt;
Ширину кармана (столбца) гистограммы можно поменять через параметры `breaks` и `col`:


```r
hist(sub$ПродЭкспорт, 
     breaks = seq(0, 3000, 200), 
     col="olivedrab3")
```
]

.pull-right[
![](05_Graphics_files/figure-html/hist-out-1.png)&lt;!-- --&gt;
]

---

# Гистограммы

.large[Гистограммы распределения строятся с помощью функции `hist()`.]

.pull-left[
&lt;br&gt;
Перед построением гистограммы часто выполняют логарифмирование:

```r
hist(log(sub$ПродЭкспорт), 
     col = "olivedrab3")
```
]

.pull-right[
![](05_Graphics_files/figure-html/histlog-out-1.png)&lt;!-- --&gt;
]

---

# Столбчатые графики

.left-40[
По умолчанию:

```r
barplot(okr$ХимЭкспорт)
```

![](05_Graphics_files/figure-html/unnamed-chunk-9-1.png)&lt;!-- --&gt;
]

.right-60[
Горизонтально с подписями:

```r
margins.default = par("mar")
par(mar = c(5, 10, 0, 2))
barplot(okr$ХимЭкспорт, 
        names.arg=sub('федеральный округ', 
                      '', okr$Регион), 
        horiz = TRUE, las = 1)
```

![](05_Graphics_files/figure-html/unnamed-chunk-10-1.png)&lt;!-- --&gt;
]

---

# Столбчатые графики

С заголовком и установленным диапазоном по оси Х:
.pull-left[

```r
par(mar = c(5, 10, 2, 2))
names = sub('федеральный округ', 
            '', okr$Регион)
barplot(
  okr$ХимЭкспорт, 
  names.arg = names,
  main = "Экспорт продукции 
  химической промышленности", 
  xlab = "млн долл. США", 
  horiz = TRUE, 
  las = 1, 
  xlim = c(0,12000)
)
```
]

.pull-right[
![](05_Graphics_files/figure-html/barfull-out-1.png)&lt;!-- --&gt;
]


---

# Круговые (секторные) диаграммы

.pull-left[
Круговые диаграммы (англ. _piechart_) строятся с помощью функции `pie()`:

```r
par(mar = c(10,3,0,2))
pie(okr$ХимЭкспорт)
```

![](05_Graphics_files/figure-html/unnamed-chunk-11-1.png)&lt;!-- --&gt;
]

.pull-right[
Вместо номеров можно использовать подписи секторов, добавив второй параметр:

```r
pie(okr$ХимЭкспорт, names)
```

&lt;img src="05_Graphics_files/figure-html/unnamed-chunk-12-1.png" width="80%" /&gt;
]

---

# Круговые (секторные) диаграммы

Заголовок, подписи процентов и отсчет по часовой стрелке:
.code-small[

```r
title = "Доля федеральных округов в экспорте\nпродукции химической промышленности"
```
]

.pull-left[
.code-small[

```r
library(glue)

percentage = round(
  100 * okr$ХимЭкспорт / 
    sum(okr$ХимЭкспорт), 1)

names2 = glue('{names} ({percentage}%)')

par(mar = c(6,5,2,5))

pie(okr$ХимЭкспорт, 
    names2, 
    clockwise = TRUE,
    main = title)
```
]
]

.pull-right[
![](05_Graphics_files/figure-html/piefull-out-1.png)&lt;!-- --&gt;
]

---

# Цвет и прозрачность

Цвет --- одно из основных графических средств, используемых на графиках и диаграммах, поэтому данная тема рассмотрена более подробно в отдельном разделе. Определить цвет можно различными способами. Во-первых, в __R__ есть палитра предопределенных цветов, которые можно выбирать по их [названию](http://research.stowers-institute.org/efg/R/Color/Chart/ColorChart.pdf)).

Список называний цветов можно посмотреть, вызвав функцию `colors()`:

```r
head(colors())
## [1] "white"         "aliceblue"     "antiquewhite"  "antiquewhite1" "antiquewhite2" "antiquewhite3"
```

Основной цвет любого графика или диграмма задается параметром `col = `. Это цвет (или цвета) с помощью которых будут отображаться данные. Попробуем изменить цвет графика с серого на пастельно-синий:

```r
par(mar = c(5, 10, 4, 2)) # увеличим поле left до 10 условных единиц
barplot(okr$ХимЭкспорт, 
        names.arg = names, 
        main = "Экспорт продукции химической промышленности", 
        xlab = "млн долл. США", 
        horiz = TRUE, 
        las = 1, 
        xlim = c(0,12000), 
        col = "steelblue")
```

![](05_Graphics_files/figure-html/unnamed-chunk-15-1.png)&lt;!-- --&gt;
Помимо этого вы можете задать цвет с помощью цветовых компонент в различных пространствах. Для этого вы должны быть знакомы с основами теории цвета (посмотрите презентацию [UsingColorInR.pdf](http://research.stowers-institute.org/efg/Report/UsingColorInR.pdf). Например, фиолетовый цвет в пространстве [RGB](https://ru.wikipedia.org/wiki/RGB) можно задать с помощью функции `rgb()`, смешав синюю и красную компоненты:

```r
violet = rgb(0.4, 0, 0.6)
barplot(okr$ХимЭкспорт, 
        names.arg = names, 
        main = "Экспорт продукции химической промышленности", 
        xlab = "млн долл. США", 
        horiz = TRUE, 
        las = 1, 
        xlim = c(0,12000), 
        col = violet)
```

![](05_Graphics_files/figure-html/unnamed-chunk-16-1.png)&lt;!-- --&gt;

Чтобы сделать цвет __полупрозрачным__, есть две возможности: 

* При создании нового цвета --- передать в функцию `rgb()` дополнительный параметр `alpha = `, который задает долю прозрачности в диапазоне от 0 до 1.
* При модификации существующего цвета --- вызвать функцию `adjustcolor()` с параметром `alpha = `

Например:

```r
violet.transp = adjustcolor(violet, alpha = 0.5)
barplot(okr$ХимЭкспорт, 
        names.arg = names, 
        main = "Экспорт продукции химической промышленности", 
        xlab = "млн долл. США", 
        horiz = TRUE, 
        las = 1, 
        xlim = c(0,12000), 
        col = violet.transp)
```

![](05_Graphics_files/figure-html/unnamed-chunk-17-1.png)&lt;!-- --&gt;

```r

green.transp = rgb(0, 1, 0, 0.5) # появился четвертый параметр
barplot(okr$ХимЭкспорт, 
        names.arg = names, 
        main = "Экспорт продукции химической промышленности", 
        xlab = "млн долл. США", 
        horiz = TRUE, 
        las = 1, 
        xlim = c(0,12000), 
        col = green.transp)
```

![](05_Graphics_files/figure-html/unnamed-chunk-17-2.png)&lt;!-- --&gt;

&gt; Функция `adjustcolor()` позволяет модифицировать все компоненты цвета, не только прозрачность. 

На графике типа _barplot_ вы имеете фактически несколько переменных, которые представлены столбиками. А это означает что для них можно использовать различные цвета. Вы можете передать в параметр `col = ` вектор из цветов, соответствующих столбикам:

```r
colors = c("red", "green", "blue", "orange", "yellow", "pink", "white","black")

barplot(okr$ХимЭкспорт, 
        names.arg = names, 
        main = "Экспорт продукции химической промышленности", 
        xlab = "млн долл. США", 
        horiz = TRUE, 
        las = 1, 
        xlim = c(0,12000), 
        col = colors)
```

![](05_Graphics_files/figure-html/unnamed-chunk-18-1.png)&lt;!-- --&gt;

На самом деле, такой винегрет из цветов на столбчатых диаграммах использовать не принято. Но вы должны понимать, что при необходимости можно поменять цвет отдельно выбранных столбиков. Например, мы можем показать красным цветом Wентральный и Приволжский округа, которые являются лидерами по экспорту продукции химической промышленности:

```r
colors = rep("gray", 8) # сделаем 8 серых цветов
colors[2] = "red"
colors[7] = "red"
barplot(okr$ХимЭкспорт, 
        names.arg = names, 
        main = "Экспорт продукции химической промышленности", 
        xlab = "млн долл. США", 
        horiz = TRUE, 
        las = 1, 
        xlim = c(0,12000), 
        col = colors)
```

![](05_Graphics_files/figure-html/unnamed-chunk-19-1.png)&lt;!-- --&gt;

Еще одна интересная особенность использования цвета заключается в том, что количество указанных цветом может не совпадать с количеством рядов данных. Вы можете указать 2 или 3 цвета, и они будут циклически повторяться при визуализации данных:

```r
colors=c("gray","steelblue")
barplot(okr$ХимЭкспорт, 
        names.arg = names, 
        main = "Экспорт продукции химической промышленности", 
        xlab = "млн долл. США", 
        horiz =TRUE, 
        las = 1, 
        xlim = c(0, 12000), 
        col = colors)
```

![](05_Graphics_files/figure-html/unnamed-chunk-20-1.png)&lt;!-- --&gt;

Наконец, вещь, которой совершенно необходимо уметь пользоваться при работе с цветом в __R__ --- это цветовые палитры. Палитры чрезвычайно удобны, когда необходимо сгенерировать множество цветов, зная лишь основные оттенки. Для этого нужно создать палитру, используя функцию `colorRampPalette()`:

```r
# задаем 2 опорных цвета: черный  белый
palet=colorRampPalette(c("black","white")) 

# и автоматически генерируем 8 цветов между ними:
colors=palet(8)

# используем их для отображения:
barplot(okr$ХимЭкспорт, 
        names.arg = names, 
        main = "Экспорт продукции химической промышленности", 
        xlab = "млн долл. США", 
        horiz = TRUE, 
        las = 1, 
        xlim = c(0, 12000), 
        col= colors)
```

![](05_Graphics_files/figure-html/unnamed-chunk-21-1.png)&lt;!-- --&gt;

```r

# вы можете включить в палитру произвольное количество цветов:
palet=colorRampPalette(c("steelblue","white","purple4")) 
colors=palet(8)
barplot(okr$ХимЭкспорт, 
        names.arg = names, 
        main = "Экспорт продукции химической промышленности", 
        xlab = "млн долл. США", 
        horiz=TRUE, 
        las = 1, 
        xlim = c(0, 12000), 
        col= colors)
```

![](05_Graphics_files/figure-html/unnamed-chunk-21-2.png)&lt;!-- --&gt;

В __R__ cуществует множество стандартных палитр, их список можно найти в справке и документации. Наиболее полезные из них:

* `colors()`
* `gray()`
* `rainbow()`
* `heat.colors()`
* `topo.colors()`
* `terrain.colors()`

Напрмер, вы можете изменить цвета диаграммы, взяв их из одной из палитр или выбрав случайным образом из полной палитры цветов, используя функцию `sample()`:

```r
pie(okr$ХимЭкспорт, names2, main = "Доля федеральных округов в экспорте \n продукции химической промышленности", col=rainbow(length(names2)))
```

![](05_Graphics_files/figure-html/unnamed-chunk-22-1.png)&lt;!-- --&gt;

```r
pie(okr$ХимЭкспорт, names2, main = "Доля федеральных округов в экспорте \n продукции химической промышленности", col=sample(colors(),5))
```

![](05_Graphics_files/figure-html/unnamed-chunk-22-2.png)&lt;!-- --&gt;

Более богатый набор палитр можно найти в библиотеке `RColorBrewer`, которая представляет собой интерпретацию палитр, доступных на сайте [colorbrewer2.org](http://colorbrewer2.org/)


```r
library(RColorBrewer) # Откроем библиотеку RColorBrewer:
display.brewer.all() # Посмотрим, какие в ней имеются палитры
```

![](05_Graphics_files/figure-html/unnamed-chunk-24-1.png)&lt;!-- --&gt;


К каждой из этих палитр можно обратиться по названию с помощью функции `brewer.pal()`. Поскольку нам необходимы цвета для категориальных данных, следует использовать палитры из средней части (_Set3 - Accent_)


```r
# выберем цвета из палитры Set2 по количеству секторов в круге:
colors = brewer.pal(length(names2),"Set1")

# И используем их при визуализации
par(mar = c(5, 5, 5, 5)) # установим поля
pie(okr$ХимЭкспорт, names2, main = "Доля федеральных округов в экспорте \n продукции химической промышленности", col=colors)
```

![](05_Graphics_files/figure-html/unnamed-chunk-26-1.png)&lt;!-- --&gt;

```r

# Попробуем палитру Accent:
pie(okr$ХимЭкспорт, names2, main = "Доля федеральных округов в экспорте \n продукции химической промышленности", col=brewer.pal(length(names2),"Accent"))
```

![](05_Graphics_files/figure-html/unnamed-chunk-26-2.png)&lt;!-- --&gt;

---

# Графические параметры

Изменять __размеры элементов графика__ можно независимо друг от друга, используя следующие параметры:

* `cex` --- общий масштаб элементов на графике
* `cex.axis` --- масштаб подписей координат на оси
* `cex.lab` ---	масштаб подписей названий осей
* `cex.main` ---	масштаб заголовка графика
* `cex.sub` ---	масштаб подзаголовка графика
* `cex.names` --- масштаб подписей факторов (для некоторых типов диаграмм)

Например:

```r
plot(tab$Год, 
     tab$Каспийское, 
     pch=20, 
     type="o", 
     ylim = c(0,12), 
     col="red3", 
     main="Объем сброса загрязненных сточных вод", 
     xlab="Год", 
     ylab="млрд.куб.м",
     cex.axis=0.8, 
     cex.lab=0.7, 
     cex.main=0.9, 
     cex = 0.8)

points(tab$Год, tab$Карское, pch=20, col="forestgreen",cex = 0.8)
lines(tab$Год, tab$Карское, pch=20, col="forestgreen")

points(tab$Год, tab$Азовское, pch=20, col="steelblue",cex = 0.8)
lines(tab$Год, tab$Азовское, pch=20, col="steelblue")
```

![](05_Graphics_files/figure-html/unnamed-chunk-27-1.png)&lt;!-- --&gt;

Аналогично происходит тонкая настройка __цвета__:

* `col`       цвет графика
* `col.axis`	цвет подписей координат
* `col.lab`   цвет названий осей
* `col.main`	цвет заголовка
* `col.sub`   цвет подзаголовка
* `fg`        цвет элементов переднего плана (оси, рамка и т.д.)
* `bg`        цвет фона графика (background)


```r
plot(tab$Год, 
     tab$Каспийское, 
     pch=20, 
     type="o", 
     ylim = c(0,12), 
     col="red3", 
     main="Объем сброса загрязненных сточных вод", 
     xlab="Год", 
     ylab="млрд.куб.м",
     cex.axis=0.8, 
     cex.lab=0.7, 
     cex.main=0.9, 
     col.lab = "grey50", 
     fg = "grey40")
points(tab$Год, tab$Карское, pch=20, col="forestgreen")
lines(tab$Год, tab$Карское, pch=20, col="forestgreen")
points(tab$Год, tab$Азовское, pch=20, col="steelblue")
lines(tab$Год, tab$Азовское, pch=20, col="steelblue")
```

![](05_Graphics_files/figure-html/plotcolors-1.png)&lt;!-- --&gt;

---

# Разметка осей, рамка, сетка координат и произвольные линии {#axes}

По умолчанию __R__ подбирает оптимальный с точки зрения него шаг разметки осей, в зависимости от разброса значений по осям `\(X\)` и `\(Y\)`, а также размеров графического устройства, на котором производится рисование. Изменяя размер окна прорисовки, вы получите различную разметку осей.

В то же время, часто возникает желание (или необходимость) самостоятельно управлять шагом разметки сетки. Для этого необходимо:

1. Вызвать функцию `plot()`, передав ей дополнительно параметр `axes = FALSE` (убирает при рисовании обе оси) или один из параметров `xaxt="n"` / `yaxt="n"` (убирают оси `\(X\)` и `\(Y\)` соответственно)
2. Вызвать столько раз функцию `axis()`, сколько вы хотите нарисовать осей, передав ей параметры для рисования каждой оси.

Функция `axis()` принимает следующие параметры:

* `side` --- сторона графика, на которой будет нарисована ось (`1=bottom`, `2=left`, `3=top`, `4=right`)
* `at` --- вектор значений, в которых должны быть нарисованы метки оси
* `labels` --- вектор подписей, которые будут нарисованы в местоположениях, указанных в параметре `at`. Этот параметр можно пропустить, если подписи совпадают с местоположениями меток
* `pos` --- координата, вдоль которой будет нарисована ось 
* `lty` --- тип линии
* `col` --- цвет линии и меток
* `las` --- расположение подписей параллельно ($0$) или перпендикулярно ($2$) оси
* `tck` --- длина метки относительно размера графика. Отрицательные значения дают метки, выходящие за пределы графика. положительные — внутрь графика. `\(0\)` убирает метки, `\(1\)` рисует линии сетки.

При ручном построении осей полезно сразу же нарисовать рамку вокруг графика, используя функцию `box()`.

Например:

```r
plot(tab$Год, 
     tab$Каспийское,
     type = "l",
     axes = FALSE)

axis(side = 1, 
     at = seq(min(tab$Год), max(tab$Год), 1),
     tck = -0.02,
     labels = FALSE) # разметим ось X через 1 год, но рисовать подписи не будем

axis(side = 1, 
     at = seq(min(tab$Год), max(tab$Год), 3), # а подписи расставим через 3 года
     tck = 0) # но рисовать метки не будем

# разметим ось Y через 1 млрд куб. м., округлив предварительно минимальное и максимальное значение до ближайшего целого снизу и сверху соответственно
axis(side = 2, 
     at = seq(floor(min(tab$Каспийское)), ceiling(max(tab$Каспийское)), 1),
     tck = -0.02) 

box() # добавим рамку для красоты
```

![](05_Graphics_files/figure-html/manual-1.png)&lt;!-- --&gt;

Для размещения сетки координат существует функция `grid(nx = NULL, ny = nx, col = "lightgray", lty = "dotted", lwd = par("lwd"), equilogs = TRUE)`. Как видно из набора ее параметров, сетка определяется количеством линий в горизонтальном и вертикальном направлении. Это не всегда бывает удобно, поскольку как правило мы хотим задать шаг сетки конкретной величины. По умолчанию, однако, линии сетки выбираются автоматически, как и метки:

```r
plot(tab$Год, 
     tab$Каспийское,
     type = "l",
     col = "red")
grid()
```

![](05_Graphics_files/figure-html/unnamed-chunk-28-1.png)&lt;!-- --&gt;

Вы, разумеется, можете поменять их количество, однако __R__ не будет за вас согласовывать шаг сетки и шаг меток осей, поскольку метки генерируются на стадии рисования `plot()` или `axis()` и не запоминаются.

```r
plot(tab$Год, 
     tab$Каспийское,
    type = "l",
    col = "red")
grid(10, 5)
```

![](05_Graphics_files/figure-html/unnamed-chunk-29-1.png)&lt;!-- --&gt;

Функция `grid()` на самом деле является оберткой функции `abline()`, которая позволяет рисовать произвольные линии на графике. Данна функция предоставляет следующие возможности построения линий и серий линий:

* `a, b` --- коэффициенты уравнения `\(y = ax + b\)`. Таким образом можно определить только одну линию.
* `coef` --- принимает вектор из двух значений, которые интерпретируются как `a` и `b`. То есть, это альтернативная форма записи предыдущего случая.
* `h` --- значение (значения) координат `\(y\)` для горизонтальной линии (серии горизонтальных линий). То есть, вы можете передать в этот параметр как одиночное значение, так и вектор значений. В зависимости это этого нарисуется одна горизонтальная линия или серия горизонтальных линий.
* `v` --- значение (значения) координат `\(x\)` для вертикальной линии (серии веритикальных линий). Работает аналогично параметру `h`.
* `reg` --- сюда можно передать объект, обладающий методом `coef()`. Этот способ можно использовать для рисования линий регрессии.

Предположим теперь, что вы хотите нарисовать сетку с шагом в 1 год по горизонтальной оси и шагом 1 млрд. куб. м по оси вертикальной. При этом вы также хотите, чтобы линии сетки располагались _под_ графиком, а не поверх его. Также необходимо выделить особым цветом значение в 10 млрд м$^3$ по оси `\(Y\)`. Для этого выполним следующую последовательность действий:

```r
plot(tab$Год, 
     tab$Каспийское, 
     type="n") # режим 'n' позволяет ничего не рисовать, но заложить поле графика в соответствии с данными, указанными в параметрах x и y

# Вычисляем линии сетки
xlines = seq(min(tab$Год), max(tab$Год), 1)
ylines = seq(ceiling(min(tab$Каспийское)),
              floor(max(tab$Каспийское)), 1)

# Рисуем линии сетки
abline(h = ylines, v = xlines, col = "lightgray")

# Рисуем график
lines(tab$Год, 
     tab$Каспийское, 
     col="red3")
points(tab$Год, 
     tab$Каспийское,
     pch = 20,
     col="red3")

# Выделяем значение 10 по оси Y:
abline(h = 10, col = "blue", lwd = 2)

# Рисуем дополнительно рамку, т.к. сетку координат мы рисовали после графика
box()
```

![](05_Graphics_files/figure-html/manualaxes-1.png)&lt;!-- --&gt;

---

# Аннотации данных (текст на графике)

Аннотации данных добавляются на график с помощью функции `text()`. В качестве  трех обязательных аргументов ей необходимо передать координаты точек размещения текста, и вектор подписей. Также полезным будет указать параметр `pos=`, отвечающий за размещение аннотации относительно точки. Значения `pos`, равные 1, 2, 3 и 4, соответствуют размещению снизу, слева, сверху и справа от точки:

```r
text(tab$Год, 
     tab$Каспийское,
     labels = tab$Каспийское,
     cex = 0.75,
     pos = 3)
```
![](05_Graphics_files/figure-html/unnamed-chunk-30-1.png)&lt;!-- --&gt;

&gt; К сожалению, стандартный механизм размещения аннотаций пакета `graphics` не обладает возможностью устранения конфликтов подписей. Однако это возможно для графиков, построенных с помощью библиотек [lattice](https://cran.r-project.org/web/packages/lattice/index.html) и [ggplot2](https://cran.r-project.org/web/packages/ggplot2/index.html). Для этого можно воспользоваться пакетом [directlabels](https://cran.r-project.org/web/packages/directlabels/index.html) или  [ggrepel](https://cran.r-project.org/web/packages/ggrepel/index.html).

---

## Легенда

Легенда к графику размещается с помощью функции `legend()`. Эта функция принимает несколько аргументов, включая: местоположение, заголовок, названия элементов, графические параметры. Местоположение может быть задано координатами `\((x,y)\)` в системе координат графика, но удобнее пользоваться следующими предопределенными константами: `"bottomright"`, `"bottom"`, `"bottomleft"`, `"left"`, `"topleft"`, `"top"`, `"topright"`, `"right"`, `"center"`. 

Чтобы в легенде появились точки, необходимо задать параметр `pch=`. Для линейной легенды, следует задать, соответственно, параметр `lty =` и/или `lwd =`. Каждый из этих параметров должен быть вектором по количеству элементов легенды:


```r
par(mar = margins.default)

# Найдем ограничивающий прямоугольник вокруг всех рядов данных
xrange = range(tab$Год)
yrange = range(tab$Каспийское, tab$Карское, tab$Азовское)

# Построим пустой график с разметкой осей и всеми заголовками
plot(xrange, 
     yrange, 
     type="n", 
     main="Объем сброса загрязненных сточных вод", 
     xlab="Год", 
     ylab="млрд.куб.м",
     cex.axis=0.8, 
     cex.lab=0.7, 
     cex.main=0.9, 
     col.lab = "grey50", 
     fg = "grey40")

# Добавим на график сетку координат
grid()

# Добавим на график данные
points(tab$Год, tab$Каспийское, pch=20, col="red3")
lines(tab$Год, tab$Каспийское, pch=20, col="red3")

points(tab$Год, tab$Карское, pch=20, col="forestgreen")
lines(tab$Год, tab$Карское, pch=20, col="forestgreen")

points(tab$Год, tab$Азовское, pch=20, col="steelblue")
lines(tab$Год, tab$Азовское, pch=20, col="steelblue")

# Определим положение, названия и цвета:
main = "Море"
location = "topright"
labels = c("Каспийское", "Карское", "Азовское")
colors = c("red3", "forestgreen", "steelblue")

# Если цвет передать в параметр fill, то по умолчанию
# нарисуются цветовые плашки:
legend(location, labels, title = main, fill=colors)
```

![](05_Graphics_files/figure-html/caspianlegend-1.png)&lt;!-- --&gt;


```r
pts = c(20, 20, 20) # каждый элемент показывается точкой типа 20
lns = c(1, 1, 1) # каждый элемент показывается линией толщиной 1

# теперь посмотрим на легенду (она нарисуется поверх старой)
legend(location, labels, title = main, col = colors, pch = pts, lwd = lns)
```

![](05_Graphics_files/figure-html/unnamed-chunk-31-1.png)&lt;!-- --&gt;

Более подробно с разнообразными опциями размещения легенды на графике вы можете познакомиться, набрав в консоли команду `?legend`.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
