---
title: "Типы данных, условия, ввод и вывод"
subtitle: "Визуализация и анализ географических данных на языке R"
author: "Тимофей Самсонов"
institute: "МГУ имени Ломоносова, Географический факультет"
date: "`r Sys.Date()`"
output:
  xaringan::moon_reader:
    css: [default, "custom.css"]
    lib_dir: libs
    nature:
      highlightLines: true
      countIncrementalSlides: false
      ratio: 16:9
---

# Типы данных

```{r setup, echo = FALSE, purl = FALSE, cache = FALSE, include=FALSE}
knitr::opts_knit$set(global.par = TRUE)
knitr::opts_chunk$set(warning=FALSE, collapse = TRUE)
```

Тип данных — это класс данных, характеризуемый членами класса и операциями, которые могут быть к ним применены. С помощью типов данных мы можем представлять привычные нам сущности, такие как числа, строки и т.д. В языке R существует 5 базовых типов данных:

<br>

Название | Тип данных
---------|-----------
`complex`  | комплексные числа
`character`| строки
`integer`  | целые числа
`logical`  | логические (булевы)
`numeric`  | числа с плавающей точкой

<!-- Помимо этого есть тип `Date`, который позволяет работать с датами. Рассмотрим использование каждого из перечисленных типов. -->

---

# Числа

Числа — основной тип данных в R. К ним относятся _числа c плавающей точкой_ и _целые числа_.

Сложение и вычитание:
```{r, collapse=TRUE}
2 + 3
2 - 3
```

Умножение и деление:
```{r, collapse=TRUE}
2 * 3
5 / 3
```

---

# Числа

Целочисленное деление `%/%`:
```{r, collapse=TRUE}
5 %/% 3
```

Остаток от деления `%%`:
```{r, collapse=TRUE}
5 %% 3
```

Возведение в степень:
```{r, collapse=TRUE}
2 ^ 3
2 ** 3
```

---

# Переменные

Как правило, в настоящих программах числа в явном виде встречаются лишь иногда.  Поскольку одно и то же число может выполнять разные функции в разных выражениях, в программе вводят переменные и присваивают им значения с помощью оператора `<-` либо `=`:
```{r, collapse=TRUE}
a <- 5
b = 3
```

Чтобы вывести значение переменной на экран, достаточно просто ввести его:
```{r, collapse=TRUE}
a
b
```

---

# Переменные

.pull-left[
Мы можем выполнить над переменными все те же операции что и над константами:
```{r, collapse=TRUE}
a + b
```
]

.pull-right[
Новую переменную можно создать на основе значений существующих переменных и констант:
```{r, collapse=TRUE}
d = b
e = a + d
f = e + 2.5

d
e
f
```
]


---

# Переменные

.pull-left[
Противоположное по знаку число получается добавлением унарного оператора `-` перед константой или переменной:
```{r, collapse=TRUE}
f = -2
f
f = -e
f
```
]

.pull-right[
Операция взятия остатка от деления бывает полезной, например, когда мы хотим выяснить, является число четным или нет:
```{r, collapse=TRUE}
d %% 2
e %% 2
```

]

---

# Числовые функции

.pull-left[
В качестве аргумента функции можно использовать переменную, константу, а также выражения:
```{r, collapse=TRUE}
sqrt(a)
tan(1.5)
abs(a + b - 2.5)
```
]

.pull-right[
Вы также можете легко вкладывать функции одна в одну, и записывать результат в переменную:
```{r, collapse=TRUE}
b = sqrt(sin(a) + 2)
b
```
]


---

# Строки

Строки состоят из символов. Чтобы создать строковую переменную, необходимо заключить текст строки в кавычки:
```{r, collapse=TRUE}
s = "В историю трудно войти, но легко вляпаться (М.Жванецкий)"
s
```

Длину строки в символах можно узнать с помощью функции `nchar()`
```{r, collapse=TRUE}
nchar(s)
```

---

# Строки

_Конкатенация_ — сцепление строк — выполняется с помощью функции `paste()`:
```{r, collapse=TRUE}
s1 = "В историю трудно войти,"
s2 = "но легко вляпаться"
s3 = "(М.Жванецкий)"
paste(s1, s2, s3)
```

Конкатенировать можно не только строки, но и числа:
```{r, collapse=TRUE}
year = 1950
pop = 1850
s1 = "Максимальная численность населения в Детройте пришлась на"
s2 = "год и составила"
s3 = "тыс. чел"
paste(s1, year, s2, pop, s3)
```

---

# Даты

Для создания даты используется функция `as.Date()`. В качестве аргумента функции необходимо задать дату, записанную в виде строки:
```{r, collapse=TRUE}
birth = as.Date('1986/02/18')
birth
```

Сегодняшнюю дату вы можете узнать с помощью специальной функции `Sys.Date()`:
```{r, collapse=TRUE}
current = Sys.Date()
current
```

---

# Даты

Вычитание дат дает интервал во времени:
```{r, collapse=TRUE}
current - birth
```

Сложение даты и интервала дает новую дату:
```{r, collapse=TRUE}
current + 40
```

---

# Логические

Логические переменные возникают там, где нужно проверить условие. Переменная логического типа может принимать значение `TRUE` (истина) или `FALSE` (ложь). Для их обозначения также возможны более компактные константы `T` и `F` соответственно.

Следующие операторы приводят к возникновению логических переменных:

* _РАВНО_ (`==`) --- проверка равенства операндов
* _НЕ РАВНО_ (`!=`) --- проверка неравенства операндов
* _МЕНЬШЕ_ (`<`) --- первый аргумент меньше второго
* _МЕНЬШЕ ИЛИ РАВНО_ (`<=`) --- первый аргумент меньше или равен второму
* _БОЛЬШЕ_ (`>`) --- первый аргумент больше второго
* _БОЛЬШЕ ИЛИ РАВНО_ (`>=`) --- первый аргумент больше или равен второму

---

# Логические

Пример логических операций:
```{r, collapse=TRUE}
a = 1
b = 2
a == b
a != b
a > b
a < b
```

---

# Логические

Если необходимо проверить __несколько условий одновременно__, их можно комбинировать с помощью логических операторов. Наиболее популярные среди них: 

* _И_ (`&&`) - проверка истинности обоих условий 
* _ИЛИ_ (`||`) - проверка истинности хотя бы одного из условий
* _НЕ_ (`!`) - отрицание операнда (истина меняется на ложь, ложь на истину)

```{r, collapse=TRUE}
c=3
(b>a) && (c>b)
(a>b) && (c>b)
(a>b) || (c>b)
!(a>b)
```

---

# Определение типа данных

Определение типа данных осуществляется с помощью функции `class()`:

```{r, collapse=T}
class(1)
class(0.5)
class(1 + 2i)
class("sample")
class(TRUE)
class(as.Date('1986-02-18'))
```

---

# Преобразование типов данных

Преобразование типов данных осуществляется с помощью функций семейства `as(d, type)`, где `d` — это входная переменная, а `type` — название типа данных, к которому эти данные надо преобразовать (см. таблицу в начале главы). Несколько примеров:
```{r, echo = FALSE, purl=FALSE}
library(methods)
```

```{r, collapse=T}
k = 1
m = as(k, "character")
m
class(m)

n = as(m, "numeric")
n
class(n)
```

---

# Преобразование типов данных

Для функции `as()` существуют обертки (_wrappers_), которые позволяют записывать такие преобразования более компактно и выглядят как `as.<datatype>(d)`, где `datatype` --- название типа данных:
```{r, collapse=T}
m = as.character(k)
m
class(m)

n = as.numeric(m)
n
class(n)

d = as.Date('1986-02-18')
d
class(d)
```

---

# Преобразование типов данных

Если преобразовать число c плавающей точкой до целого, то дробная часть будет отброшена:
```{r, collapse=T}
as.integer(2.7)
```

После преобразования типа данных к переменной будут применимы только те функции, которые определены для данного типа данных:
```{r, collapse=T, error=T}
a = 2.5
b = as.character(a)
b + 2
nchar(b)
```

---

# Проверка типов данных и пустых значений

Для проверки типа данных можно использовать функции семейства `is.<datatype>`:
```{r, collapse=T}
is.integer(2.7)
is.numeric(2.7)
is.character('Привет!')
```

Особое значение имеют функции проверки пустых переменных (имеющих значение `NA` - not available), которые могут получаться в результате несовместимых преобразований или пропусков в данных:

```{r, collapse=T}
as.integer('Привет!')
```

---

# Ввод данных c консоли

Для ввода данных через консоль можно воспользоваться функцией `readline()`, которая будет ожидать пользовательский ввод и нажатие клавиши <kbd>Enter</kbd>, после чего вернет введенные данные в виде строки. 

Предположим, пользователь вызывает эту функцию и вводит с клавиатуры `1024`:

```{r, echo=FALSE, purl=FALSE}
a = "1024"
```
```{r, eval=F}
a = readline()
```
Выведем результат на экран:
```{r, collapse=TRUE}
a
```

__Функция `readline()` всегда возвращает строку, поэтому если вы ожидаете ввод числа, полученное значение необходимо явным образом преобразовать к числовому типу__

---

# Вывод данных на консоль

Для вывода данных в консоль можно воспользоваться тремя способами:

- Просто напечатать название переменной с новой строки (_не работает при запуске программы командой `Source`_)
- Вызвать функцию `print()`
- Вызвать функцию `cat()`
- Заключить выражение в круглые скобки `()`

Функция `print()` работает точно так же, как и просто название переменной с новой строки, отличаясь лишь двумя особенностями:

- `print()` явным образом говорит о том, что вы хотите вывести в консоль некую информацию
- `print()` работает при любых методах запуска программы, в том числе методом `Source`.

---

# Вывод данных на консоль

```{r, collapse=TRUE}
a = 1024
a
print(a)

b = "Fourty winks in progress"
b
print(b)

print(paste("2 в степени 10 равно", 2^10))

print(paste("Сегодняшняя дата - ", Sys.Date()))
```

---

# Вывод данных на консоль

Функция `cat()` отличается от `print()` следующими особенностями:

- `cat()` выводит значение переменной, и не печатает ее измерения и внешние атрибуты.
- `cat()` принимает множество аргументов и может осуществлять конкатенацию строк аналогично функции `paste()`
- `cat()` не возвращает никакого значений, в то время как `print()` возвращает значение, переданное ей в качестве аргумента.
- `cat()` можно использовать только для атомарных типов данных. Для классов (таких как Date) она будет выводит содержимое объекта, которое может не совпадать с тем, что пользователь ожидает вывести 

---

# Вывод данных на консоль

```{r, collapse=TRUE}
cat(b)

cat("2 в степени 10 равно", 2^10)

cat("Сегодняшнаяя дата -", Sys.Date())
```

---

# Вывод данных на консоль

Вывод с помощью круглых скобок позволяет выводить результат выполнения выражения:
```{r}
(a = rnorm(1)) # сгенерируем случайное число, запишем в переменную и выведем на экран
(b = 2 * a) # переменная a доступна, ее можно использовать и далее для вычислений
```

---

# Условный оператор

Проверка условий позволяет осуществлять так называемое ветвление в программе. Ветвление означает, что при определенных условиях (значениях переменных) будет выполнен один программный код, а при других условиях — другой. 

Для проверки условий используется условный оператор __if --- else if --- else__ следующего вида:
```
if (condition) {
  statement1
} else if (condition) {
  statement2
} else {
  statement3
}
```

---

# Условный оператор

Например, сгенерируем случайное число, округлим его до одного знака после запятой и проверим относительно нуля:
```{r}
(a = round(rnorm(1), 1))

if (a < 0){
  cat('Получилось отрицательное число!')
} else if (a > 0) {
  cat('Получилось положительное число!')
} else {
  cat('Получился нуль!')
}
```

---

# Условный оператор

Условия часто нужны для обработки пользовательского ввода:

```{r, eval=F}
cat('Введите широту вашей точки:')
phi = as.numeric(readline())
```

```{r, echo=FALSE, purl=FALSE}
phi = 69
```

Пользователь вводит `68`, мы оцениваем результат:
```{r}
if (!is.na(phi)) { # проверяем, получилось ли преобразовать к числу
  if (abs(phi) >= 66.562 & abs(phi) <= 90) { # выполняем проверку на заполярность
    cat('Точка находится в Заполярье')
  } else {
    cat('Точка не находится в Заполярье')
  }
} else {
  cat('Необходимо ввести число!') # оповещаем о некорректном вводе
}
```

---

# Оператор переключения

Оператор переключения (switch) является удобен, когда надо сделать выбор на основе _конечного_ множества значений. Например, определим столицу Федерального округа по его названию:
```{r}
name = "Приволжский"
capital = switch(name,
                 'Центральный' = 'Москва',
                 'Северо-Западный' = 'Санкт-Петербург',
                 'Южный' = 'Ростов-на-Дону',
                 'Северо-Кавказский' = 'Пятигорск',
                 'Приволжский' = 'Нижний Новгород',
                 'Уральский' = 'Екатеринбург',
                 'Сибирский' = 'Новосибирск',
                 'Дальневосточный' = 'Хабаровск')
print(capital)
```