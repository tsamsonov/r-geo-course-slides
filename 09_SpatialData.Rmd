---
title: "Пространственные данные"
subtitle: "Визуализация и анализ географических данных на языке R"
author: "Тимофей Самсонов"
institute: "МГУ имени Ломоносова, Географический факультет"
date: "`r Sys.Date()`"
output:
  xaringan::moon_reader:
    css: [default, "custom.css"]
    lib_dir: libs
    nature:
      highlightLines: true
      countIncrementalSlides: false
      ratio: 16:9
---

```{r setup, echo = FALSE, purl = FALSE, cache = FALSE, include=FALSE}
library(datasets)
knitr::knit_hooks$set(crop = knitr::hook_pdfcrop)
knitr::opts_knit$set(global.par = TRUE)
knitr::opts_chunk$set(warning=FALSE, collapse=TRUE, message = FALSE, dpi=300)
```

## Используемые пакеты

```{r}
library(sf)
library(stars)
library(mapview)
library(dplyr)
library(readr)
```

---

## Модели пространственных данных

__Пространственный объект__ (feature) — это цифровая модель материального или абстрактного объекта реального или виртуального мира с указанием его идентификатора, координатных и атрибутивных данных.

<br>
__Пространственные данные__ (spatial data) — это данные о пространственных объектах и их наборах. 

<br>

.pull-left[
.red[_Векторная модель_] пространственных данных представляет отдельные объекты путем координатного описания их границ, а также привязанных к ним характеристик — атрибутов.
]

.pull-right[
.blue[_Растровая модель_] пространственных данных представляет географическое пространство в виде непрерывного покрытия матрицей ячеек, к каждой из которых привязаны характеристики.
]

---

class: center, middle

# Векторные данные

---

## Simple Features

__Simple Features__ (официально _Simple Features Access_) — это стандарт [OGC 06-103](http://www.opengeospatial.org/standards/sfa), который определяет общую модель хранения и доступа к векторным объектам в географических информационных системах.

- Все геометрии состоят из точек. 
- Точки являются координатами в 2-, 3- или 4-мерном пространстве. 
- Все точки в геометрии имеют одинаковую размерность. 

В дополнение к обязательным измерениям $X$ и $Y$ _возможны_ два дополнительных:

- $Z$, обозначающее высоту
- $M$, обозначающее некоторую меру, связанную с точкой — например, время

Таким образом, существует 4 варианта геометрии: $XY$, $XYZ$, $XYM$ и $XYZM$.

В географических координатах $X$ соответствует долготе, $Y$ соответствует широте.

---

## Simple Features

Стандарт включает в себя 17 типов геометрий. Наиболее употребительны следующие.

<br>
.blue[__Простые геометрии__]

Тип |	Описание
----|--------------------------------------------------------------------------------
`POINT`	| нуль-мерная геометрия, содержащая одну точку
`LINESTRING` | последовательность точек, соединенных прямыми, несамопересекающимися отрезками; одномерная геометрия
`POLYGON`	| геометрия с положительной площадью (двумерная); последовательность точек, отрезки между которыми формируют замкнутое кольцо без самопересечений; первое кольцо является внешним, ноль и более остальных колец представляют дырки внутри полигона

---

## Simple Features

Стандарт включает в себя 17 типов геометрий. Наиболее употребительны следующие.

<br>
.red[__Мультигеометрии__]

Тип |	Описание
----|--------------------------------------------------------------------------------
`MULTIPOINT` | множество точек; геометрия типа `MULTIPOINT` называется _простой_ если ни одна пара точек в `MULTIPOINT` не совпадает
`MULTILINESTRING`	| множество линий
`MULTIPOLYGON`	| множество полигонов
`GEOMETRYCOLLECTION`	| множество геометрий произвольного типа за исключением `GEOMETRYCOLLECTION`

Оставшиеся виды геометрий _Simple Features_ включают: `CIRCULARSTRING`, `COMPOUNDCURVE`, `CURVEPOLYGON`, `MULTICURVE`, `MULTISURFACE`, `CURVE`, `SURFACE`, `POLYHEDRALSURFACE`, `TIN`, `TRIANGLE`.

---

## Simple Features

```{r, echo = FALSE}
p = st_point(c(0.5,0.5))

pc = rbind(c(0.5,0.5), c(1, 3), c(2, 1), c(0.2, 2), c(2, 3), c(1.5, 1.5))
mp = st_multipoint(pc)

s1 = rbind(c(0,1),c(0.5,1.5),c(1.2,1.2),c(2,1.3),c(3,2))
ls = st_linestring(s1)

s1 = rbind(c(0.5,1.5),c(1.2,1.2),c(2,1.3))
s2 = rbind(c(0,1.5),c(0.5,2.0),c(1.2,1.7))
s3 = rbind(c(2,1.8),c(3,2.5))
mls = st_multilinestring(list(s1,s2,s3))

p1 = rbind(c(0.5,0.5), c(2,0), c(3,2), c(1.5,4), c(0,3), c(0.5,0.5))
p2 = rbind(c(1,1), c(0.8,2), c(2,2.2), c(1.4,1.1), c(1,1))
pol = st_polygon(list(p1, p2))
p3 = rbind(c(3,3.3), c(3.5, 3.1), c(4,3), c(4,3.7), c(3.7, 3.96), c(3.2,4), c(3,3.3))
p4 = rbind(c(3.2,3.4), c(3.8,3.2), c(3.8,3.7), c(3.3,3.8), c(3.2,3.4))
p5 = rbind(c(3,1.2), c(2.5,0.2), c(3.5,0.2), c(3.5,1.2), c(3,1.2))
p6 = rbind(c(0,1), c(0.1,0.8), c(0.2,0.5), c(0.1,0.3), c(0, 0.7), c(0,1))
mpol = st_multipolygon(list(list(p1,p2), list(p3,p4), list(p5), list(p6)))

gc = st_geometrycollection(list(pol, mp + c(3, -1), mls + c(2.5,2)))
```

```{r, echo=FALSE,fig.width=16, fig.height=8, fig.show='hold'}
par(mfrow = c(2,3))
plot(p, cex = 5, pch = 20, main = 'POINT', cex.main=3)
plot(ls, lwd = 3, main = 'LINESTRING', cex.main=3)
plot(pol, lwd = 3, col = 'grey', main = 'POLYGON', cex.main=3)
plot(mp, cex = 5, pch = 20, main = 'MULTIPOINT', cex.main=3)
plot(mls, lwd = 3, main = 'MULTILINESTRING', cex.main=3)
plot(mpol, lwd = 3, col = 'grey', main = 'MULTIPOLYGON', cex.main=3)
# plot(gc, lwd = 3, col = 'grey', border = 'black', main = 'GEOMETRYCOLLECTION', cex.main=3)
par(mfrow = c(1,1))
```

---

## Форматы представления

.blue[__Well-Known Text (WKT)__] — текстовый формат (удобен для визуализации)

```{r, echo=FALSE, collapse=T}
cat(st_as_text(p))
cat(st_as_text(ls))
cat(st_as_text(pol))
cat(st_as_text(mp))
cat(st_as_text(mls))
cat(st_as_text(mpol))
cat(st_as_text(gc))
```

.red[__Well-Known Binary (WKB)__] — бинарный формат (предпочтителен для хранения)

```{r, echo=FALSE}
cat(st_as_binary(p))
cat(st_as_binary(ls))
cat(st_as_binary(pol))
cat(st_as_binary(mp))
cat(st_as_binary(mls))
cat(st_as_binary(mpol))
cat(st_as_binary(gc))
```

---

## Базовые библиотеки

.left-40[
В R существует высоко развитая инфраструктура для работы с векторными данными, которая обеспечивается пакетом [__sf__](https://cran.r-project.org/web/packages/sf/index.html).

<br>
__sf__ опирается на библиотеки [PROJ](https://proj.org), [GDAL](https://gdal.org), [GEOS](https://trac.osgeo.org/geos/) и [S2](https://s2geometry.io), которые устанавливаются вместе с ним.
]

.right-60[
```{r, echo=FALSE}
knitr::include_graphics('img/sf_architecture_new.svg')
```
]

---

## Чтение

Для чтения данных средствами __sf__ необходимо использовать функцию `st_read()`:
```{r, collapse = TRUE}
countries = st_read('../r-geo-course/data/ne/countries.gpkg')
```

- Коллекция из 183 пространственных объектов с 72 атрибутами
- Тип геометрии `MULTIPOLYGON`, размерность геометрии $XY$
- Ограничивающий прямоугольник (разброс координат) по осям $X$ и $Y$ имеет диапазон $[-180, 180] \times [-90, 83.64513]$
- Проекция (CRS — coordinate reference system) имеет название _WGS 84_.

---

## Чтение

Подгрузим также для работы данные по другим типам объектов:
```{r}
oceans = st_read('../r-geo-course/data/ne/oceans.gpkg', quiet = TRUE)
rivers = st_read('../r-geo-course/data/ne/rivers.gpkg', quiet = TRUE)
lakes = st_read('../r-geo-course/data/ne/lakes.gpkg', quiet = TRUE)
cities = st_read('../r-geo-course/data/ne/cities.gpkg', quiet = TRUE)
```

> Параметр `quiet = TRUE` отключает вывод информации о загруженных данных.

---

## Внутренняя структура

Представление пространственных объектов типа Simple Features реализовано в виде иерархии из трех классов объектов:

1. `sf` (simple features) — объект класса `data.frame`, представляющий множество пространственных объектов со списком-колонкой для хранения геометрии.
1. `sfc` (simple features geometry column) — список-колонка в объекте `sf`, представляющий множество геометрий пространственных объектов.
1. `sfg` (simple feature geometry) — геометрия пространственного объекта внутри списка `sfc`.

Поскольку Simple Features реализованы в виде обычных фреймов данных, _любая операция, применимая к фрейму данных, будет также применима к объекту типа_ `sf`:

```{r}
class(countries)
```


---

## Внутренняя структура

Геометрия пространственных объектов хранится в одном из столбцов. В данном случае он имеет название `geometry`:
```{r, collapse = TRUE}
head(countries['geometry'])
```

---

## Внутренняя структура

Геометрический столбец можно извлечь, применив функцию `st_geometry()`. Полученный объект будет иметь тип __sfc__ (Simple Feature Geometry Column):

```{r, collapse = TRUE}
outlines = st_geometry(countries)
class(outlines)
head(outlines)
```

В данном случае объекты имеют класс `sfc_MULTIPOLYGON`, который является расширением класса `sfc` (simple feature geometry column).

---

## Внутренняя структура

.pull-left[
Поскольку объект класса `sfc` представляет собой список, любой элемент (отдельный объект) можно извлечь по его порядковому номеру:
```{r, results = 'asis'}
obj = outlines[[8]]
class(obj)
```

<br>
Геометрия 8-го объекта имеет класс `sfg`, реализованный в виде мультиполигонов (`MULTIPOLYGON`) с плоскими координатами (`XY`)
]

.pull-right[
Чтобы добраться до координат, необходимо развернуть иерархию списков, из которых состоит `sfg`:
```{r}
outlines[[8]][[1]]
```
]

---

## Визуализация (базовая графика)

По умолчанию выполняется графический обзор атрибутов объектов
```{r}
plot(countries)
```

---

## Визуализация (базовая графика)

Если задача стоит нарисовать границы объектов, то нужно отображать объект __sfc__:
```{r, fig.width=9, fig.height=3}
plot(st_geometry(countries))
```

---

## Визуализация (базовая графика)

Для быстрого построения тематических карт по выбранному показателю необходимо при вызове функции `plot()` указать соответствующий атрибут фрейма данных:
```{r, fig.width=9, fig.height=3}
plot(countries['sovereignt'], key.pos = NULL) # Здесь легенда не нужна
```

---

## Визуализация (базовая графика)

Для отображения координатной сетки надо указать параметр `graticule = TRUE`, а подписей координат — `axes = TRUE`:
```{r, fig.width=9, fig.height=3}
plot(countries['gdp_md_est'], graticule = TRUE, axes = TRUE)
```

---

## Визуализация (базовая графика)

Для совмещения нескольких слоев на одной карте необходимо при втором и последующих вызовах функции `plot()` указать параметр `add = TRUE`. 

.pull-left[
.code-small[
```{r complot, eval=F}
cities_large = cities |> 
  filter(scalerank == 0, 
         ! name %in% c('Washington, D.C.', 'Paris', 'Riyadh', 'Rome', 'São Paulo', 'Kolkata'))
plot(st_geometry(countries), lwd = 0.5, 
     border = 'gray', xlim = c(-180,180))
plot(oceans, col = 'steelblue1', 
     border = 'steelblue', add = TRUE)
plot(lakes, col = 'steelblue1', 
     border = 'steelblue', add = TRUE)
plot(rivers, col = 'steelblue', 
     add = TRUE)
plot(cities_large, col = 'black', 
     pch = 19, cex = 0.25, add = TRUE)
text(cities_large$longitude, 
     cities_large$latitude, 
     label = cities_large$name, 
     cex = 0.5, pos = 2, offset = 0.25)
```
]
]

.pull-right[
```{r, ref.label='complot', echo=F, fig.width=5, fig.height=5, crop = TRUE}
par(mar = rep(0,4))
```
]

---

## Визуализация (интерактивная)

Для интерактивного исследования объектов можно использовать пакет `mapview`:
```{r, eval = FALSE}
mapview(countries)
```
```{r, echo = FALSE}
knitr::include_graphics('img/mapview1.png')
```

---

## Визуализация (интерактивная)

Отображение показателей цветом осуществляется через параметр `col.regions`:

```{r, eval = FALSE}
nconts = length(unique(countries$continent))
mapview(countries, zcol = 'continent', 
        col.regions = RColorBrewer::brewer.pal(nconts, 'Set1'))
```
```{r, echo = FALSE}
knitr::include_graphics('img/mapview2.png')
```

---

## Визуализация (интерактивная)

Несколько слоев складываются через `+` как в __ggplot2__:
.code-small[
```{r, eval=FALSE}
mapview(countries, zcol = 'continent', 
        col.regions = RColorBrewer::brewer.pal(nconts, 'Set1')) + #<<
  mapview(cities_large, col.regions = 'black', label = 'name', cex = 3) } |> 
  leafem::addStaticLabels(cities_large, label = cities_large$name,
                          offset = c(0.1, 0),
                          style = list("color" = "black", "font-weight" = "bold"))
```
]

```{r, echo = FALSE}
knitr::include_graphics('img/mapview3.png')
```

---

## Атрибутивные операции

К объектам `sf` применимы стандартные преобразования фреймов данных.

.pull-left[
__Италия__:
```{r, out.width = '250px', crop = T}
italy = countries |> 
  filter(sovereignt == 'Italy')
plot(st_geometry(italy))
```
]

.pull-right[
__Cтраны более 100 млн. жителей__:
```{r, out.width = '400px', crop = T}
largest = countries |> 
  select(pop_est) |> 
  filter(pop_est > 100000000)
plot(outlines, col = 'lightgrey')
plot(largest, col = 'red', add = TRUE)
```
]

---

## Атрибутивные операции

.pull-left[
__Валовой региональный продукт по континентам:__

```{r grp, eval = F}
continents = countries %>%
  filter(., st_is_valid(.)) |>
  group_by(continent) |>  
  summarise(gdp = sum(gdp_md_est))
plot(continents['gdp'])
```
]

.pull-right[
```{r, ref.label='grp', out.width = '400px', crop = T, echo = F}
```
]

---

## Геометрические объекты (sfg)

Для создания геометрических объектов класса `sfg` существует ряд функций:

Функция                   | Тип пространственного объекта
--------------------------|-----------------------------------
`st_point()`              | _POINT_
`st_linestring()`         | _LINESTRING_
`st_polygon()`            | _POLYGON_
`st_multipoint()`         | _MULTIPOINT_
`st_multilinestring()`    | _MULTILINESTRING_
`st_multipolygon()`       | _MULTIPOLYGON_
`st_geometrycollection()` | _GEOMETRYCOLLECTION_

<br><br><br><br><br><br><br><br><br><br><br>

В зависимости от типа создаваемого объекта, данные функции принимают координаты в виде вектора, матрицы или списка.

---

## Точки

Проще всего создаются отдельные __точки__ (_POINT_):
```{r, message = T}
st_point(c(0, 2)) # XY POINT
st_point(c(0, 2, -1)) # XYZ POINT
st_point(c(0, 2, 5), dim = 'XYM') # XYM POINT
st_point(c(0, 2, -1, 5)) # XYZM POINT
```

Дополнительный параметр `dim=` служит для уточнения типа геометрии точек и по сути нужен только тогда, когда необходимо создать редко используемые точки типа _XYM_. Во всех остальных случаях (_XY_, _XYZ_, _XYZM_) размерность геометрии распознается по умолчанию.

---

## Мультиточки и линии

При создании __мультиточек__ (`MULTIPOINT`) и __линий__ (`LINESTRING`) необходимо подавать на вход функции уже матрицу координат:
```{r, message = T}
coords = matrix(c(
  0, 2,
  1, 3,
  3, 1,
  5, 0
), ncol = 2, byrow = TRUE)

mp = st_multipoint(coords) # XY MULTIPOINT
print(mp)

ls = st_linestring(coords) # XY LINESTRING
print(ls)
```

---

## Мультиточки и линии

.pull-left[
В первом случае геометрия состоит из отдельных точек. Во втором случае те же самые точки соединены линией:
```{r pntline, eval=F}
plot(ls)
plot(mp, col = 'red', 
     pch = 19, add = TRUE)
```

> .small[Создание трех-(_XYZ_, _XYM_) и четырехмерных (_ZYXM_) мультиточек и линий выполняется аналогично, но матрица должна содержать не 2, а, соответственно 3 или 4 столбца, и при необходимости параметр `dim = 'XYM'`.]
]

.pull-right[
```{r ref.label='pntline', echo = F}
```
]

---

## Полигоны

Полигоны создаются на основе списков матриц координат.

.pull-left[
```{r, message = T}
# Координаты границы
coords = matrix(c(
  1, 0,
  0, 2,
  2, 3,
  4, 2,
  3, 0.5,
  1, 0
), ncol = 2, byrow = TRUE)

# Простой полигон без дырки
pol = st_polygon(list(coords))
print(pol)
```
]

.pull-right[
```{r, out.width='400px', crop = T}
plot(pol, col = 'lightblue')
```
]

---

## Полигоны

Вторая и последующие матрицы координат в списке определяют границы дырок.

.pull-left[
```{r, message = T}
# Координаты дырки
hole = matrix(c(
  2, 1,
  3, 1.5,
  3, 2,
  2, 2,
  1.5, 1.5,
  2, 1
), ncol = 2, byrow = TRUE)

# Полигон с дыркой
pol2 = st_polygon(list(coords, hole))
print(pol2)
```
]

.pull-right[
```{r, out.width='400px', crop = T}
plot(pol2, col = 'lightblue')
```
]

---

## Мультиполигоны

.pull-left[
```{r}
coords1 = matrix(c(
  0.5, 0,
  0, 1,
  1, 1.5,
  2, 1,
  1.5, 0.25,
  0.5, 0
), ncol = 2, byrow = TRUE)

coords2 = matrix(c(
  3, 1,
  2.5, 2,
  3.5, 2.5,
  4, 2,
  4, 1.25,
  3, 1
), ncol = 2, byrow = TRUE)
```
]

.pull-right[
Мультиполигоны (`MULTIPOLYGON`) и мультилинии (`MULTILINESTRING`) требуются, когда один географический объект состоит из нескольких геометрических объектов. В мультиполигонах добавляется еще один уровень вложенности списков.

```{r, message=T}
mpol = st_multipolygon(
  list(
    list(coords1), 
    list(coords2)
  )
)
print(mpol)
```
]

---

## Мультиполигоны

```{r, out.width='500px', crop=T}
plot(pol, col = 'grey') # Обычный полигон (серый)
plot(mpol, col = 'pink', add = TRUE) # Мультиполигон (розовый)
```

---

## Мультиполигоны

Пример из практики: остров на озере как часть суши.

.pull-left[
```{r, message = T}
coords4 = matrix(c(
  2.2, 1.2,
  2.8, 1.5,
  2.8, 1.8,
  2.2, 1.8,
  2.0, 1.6,
  2.2, 1.2
), ncol = 2, byrow = TRUE)

island = st_polygon(list(coords4))
mpol2 = st_multipolygon(
  list(pol2, island)
)
print(mpol2)
```
]

.pull-right[
```{r, crop = T}
plot(mpol2, col = 'olivedrab')
```
]

---

## Мультилинии

Мультилиния, в отличие от мультиполигона, не требует дополнительного списка верхнего уровня, поскольку линии не могут содержать дыр. Например, можно собрать мультилинию из двух частей, соответствующих участкам реки до и после озера:

.pull-left[
```{r, message=T}
coords1 = matrix(c(
  -3, 0,
  -1, 2,
  0, 2
), ncol = 2, byrow = TRUE)
coords2 = matrix(c(
  4, 2,
  5, 3,
  6, 5
), ncol = 2, byrow = TRUE)
mline = st_multilinestring(list(coords1, coords2))
print(mline)
```
]

.pull-right[
```{r, out.height='250px', crop=T}
plot(mline, lwd = 3, col = 'blue')
plot(pol2, col = 'lightblue', add = TRUE)
```
]

---

## Геометрические коллекции

Геометрическая коллекция (`GEOMETRYCOLLECTION`) позволяет хранить вместе любые виды геометрий. Коллекции редко создаются напрямую, чаще они получаются в результате выполнения геометрических операций типа оверлея.

```{r, message=T}
col = st_geometrycollection(list(ls, mp, mline, pol2))
print(col)
```

.pull-left[
```{r geomcol, eval=F}
plot(col)
```

]

.pull-right[
```{r, ref.label='geomcol', echo=F, out.height='200px', crop=T}
```

]

---

## Списки геометрических объектов (sfc)

Списки геометрических объектов (класс `sfc`) используются в таблицах пространственных объектов в качестве столбца, который хранит геометрию объектов.

```{r, message = T}
moscow.sfg = st_point(c(37.615, 55.752))
irkutsk.sfg = st_point(c(104.296, 52.298))
petro.sfg = st_point(c(158.651, 53.044))

cities.sfc = st_sfc(moscow.sfg, irkutsk.sfg, petro.sfg)
print(cities.sfc)
```

---

## Списки геометрических объектов (sfc)

При создании списка геометрий для него может быть определена система координат:

```{r}
st_crs(cities.sfc) = st_crs(4326) # WGS84
print(cities.sfc)
```

> Для списка геометрий может быть определена только одна система координат

---

## Списки геометрических объектов (sfc)

Куда легли созданные точки?

```{r, out.height = '250px', crop = T}
plot(cities.sfc, pch = 19)
countries |> 
  filter(sovereignt == 'Russia') |> 
  st_geometry() |>
  plot(add = TRUE)
```