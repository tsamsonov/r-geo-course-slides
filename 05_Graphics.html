<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Основы графики</title>
    <meta charset="utf-8" />
    <meta name="author" content="Тимофей Самсонов" />
    <meta name="date" content="2021-10-04" />
    <script src="libs/header-attrs-2.11/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="custom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Основы графики
## Визуализация и анализ географических данных на языке R
### Тимофей Самсонов
### МГУ имени Ломоносова, Географический факультет
### 2021-10-04

---




# Исходные данные

Мы будем работать с региональной статистикой Росстата: экспорт/импорт продукции по регионам России (млн долл. США) и объем сброса сточных вод по морям России (млрд м$^3$):


```r
library(readxl)

# Прочтем таблицу по экспорту/импорту продукции в регионах России 
types = c("text", rep("numeric", 12))
tab = read_excel("../r-geo-course/data/ExpImp.xlsx", 1, col_types = types)

# Выгрузим данные по федеральным округам в отдельную таблицу
filter = grep("федеральный округ", tab$Регион)
okr = tab[filter, ]

# Отсортируем данные по федеральным округам в алфавитном порядке:
okr = okr[order(okr$Регион), ]

# Выгрузим данные по субъектам в отдельную таблицу
filter = grepl("федеральный округ|Федерация|числе",tab$Регион)
sub = tab[!filter, ]
```

---

# Диаграммы рассеяния


```r
par(mar=c(4,4,3,2))
# Диаграмма рассеяния по экспорту и импорту:
plot(sub$МетЭкспорт, 
     sub$МетИмпорт,
     col="red", 
     xlab="Экспорт, млн. долл. США", 
     ylab = "Импорт, млн. долл. США", 
     main = "Экспорт/импорт металлов и изделий из них по субъектам РФ")
```

![](05_Graphics_files/figure-html/unnamed-chunk-2-1.png)&lt;!-- --&gt;

---

# Диаграммы рассеяния

При построении диаграмм рассеяния важно сохранить одинаковый масштаб по осям `\(X\)` и `\(Y\)`. Чтобы обеспечить это условие, необходимо использовать параметр `asp = 1`:

```r
plot(sub$МетЭкспорт, 
     sub$МетИмпорт, 
     col="red", 
     xlab="Экспорт, млн. долл. США", 
     ylab = "Импорт, млн. долл. США", 
     main = "Экспорт/импорт металлов и изделий из них по субъектам РФ", 
     asp = 1)
```

![](05_Graphics_files/figure-html/unnamed-chunk-3-1.png)&lt;!-- --&gt;

---

# Диаграммы рассеяния

_Размер и тип значка_ можно изменить, используя параметры `pch =` и `cex =`. Размеры масштабируются параметром `cex` относительно условной единицы — стандартного размер значка. Сам значок можно выбрать, используя его код в соответствии с нижеприведенным рисунком (на самом деле, вы можете выбирать произвольные символы для визуализации точек):

![_Типы символов R_](images/pch.jpg)


```r
plot(sub$МетЭкспорт, 
     sub$МетИмпорт, 
     col="red", 
     xlab="Экспорт, млн. долл. США", 
     ylab = "Импорт, млн. долл. США", 
     main = "Экспорт/импорт металлов и изделий из них по субъектам РФ", 
     asp = 1,
     pch = 2, 
     cex = 0.5)
```

![](05_Graphics_files/figure-html/unnamed-chunk-4-1.png)&lt;!-- --&gt;

```r
plot(sub$МетЭкспорт, 
     sub$МетИмпорт, 
     col="red", 
     xlab="Экспорт, млн. долл. США", 
     ylab = "Импорт, млн. долл. США", 
     main = "Экспорт/импорт металлов и изделий из них по субъектам РФ", 
     asp = 1,
     pch = 20, 
     cex = 1.2)
```

![](05_Graphics_files/figure-html/unnamed-chunk-4-2.png)&lt;!-- --&gt;

---

# Линейные графики

Линейные графики отражают связь между зависимой и независимой переменной. Существует два способа нанесения линий на график: явное рисование линий _поверх уже построенного графика_ с помощью функции `lines()`, или создание нового линейного графика с помощью функции `plot()` с дополнительным параметром `type = `. 

Для иллюстрации принципов работы первого способа откроем еще раз данные по объему сброса загрязненных сточных вод по морям России (млрд куб. м):

```r
tab = readr::read_csv2("../r-geo-course/data/oxr_vod.csv")
## ℹ Using "','" as decimal and "'.'" as grouping mark. Use `read_delim()` for more control.
## 
## ── Column specification ────────────────────────────────────────────────────────
## cols(
##   Год = col_double(),
##   Всего = col_double(),
##   Балтийское = col_double(),
##   Черное = col_double(),
##   Азовское = col_double(),
##   Каспийское = col_double(),
##   Карское = col_double(),
##   Белое = col_double(),
##   Прочие = col_double()
## )
plot(tab$Год, tab$Каспийское, pch=20) # для начала нанесем точки
lines(tab$Год, tab$Каспийское) # теперь нанесем линии
```

![](05_Graphics_files/figure-html/unnamed-chunk-5-1.png)&lt;!-- --&gt;

По умолчанию функция `plot()` рисует именно точки. Однако если точки не нужны, а достаточно только линий, или требуется иной подход к построению графиков, можно задать параметр `type = `, который принимает следующие значения:

* `"p"` for points,
* `"l"` for lines,
* `"b"` for both,
* `"c"` for the lines part alone of "b",
* `"o"` for both ‘overplotted’,
* `"h"` for ‘histogram’ like (or ‘high-density’) vertical lines,
* `"s"` for stair steps,
* `"S"` for other steps, see ‘Details’ below,
* `"n"` for no plotting.

Попробуем разные методы визуализации:

```r
plot(tab$Год, tab$Карское,pch=20)
```

![](05_Graphics_files/figure-html/unnamed-chunk-6-1.png)&lt;!-- --&gt;

```r
plot(tab$Год, tab$Каспийское, type="p")
```

![](05_Graphics_files/figure-html/unnamed-chunk-6-2.png)&lt;!-- --&gt;

```r
plot(tab$Год, tab$Каспийское, type="l")
```

![](05_Graphics_files/figure-html/unnamed-chunk-6-3.png)&lt;!-- --&gt;

```r
plot(tab$Год, tab$Каспийское, type="b")
```

![](05_Graphics_files/figure-html/unnamed-chunk-6-4.png)&lt;!-- --&gt;

```r
plot(tab$Год, tab$Каспийское, type="c")
```

![](05_Graphics_files/figure-html/unnamed-chunk-6-5.png)&lt;!-- --&gt;

```r
plot(tab$Год, tab$Каспийское, type="o")
```

![](05_Graphics_files/figure-html/unnamed-chunk-6-6.png)&lt;!-- --&gt;

```r
plot(tab$Год, tab$Каспийское, type="h")
```

![](05_Graphics_files/figure-html/unnamed-chunk-6-7.png)&lt;!-- --&gt;

```r
plot(tab$Год, tab$Каспийское, type="s")
```

![](05_Graphics_files/figure-html/unnamed-chunk-6-8.png)&lt;!-- --&gt;

_Толщину и тип линии_ можно изменить, используя параметры `lwd =` и `lty =` соответственно. Работают они аналогично параметрам pch и cex для точечных символов. Типов линий по умолчанию в стандартной библиотеке R не так много, но в сочетании с цветовым кодированием и толщиной их оказывается вполне достаточно:
![_Типы линий в R_](images/lty.png)

Попробуем разные варианты представления линий:

```r
plot(tab$Год, tab$Каспийское, type="l", lwd = 2, lty = 1)
```

![](05_Graphics_files/figure-html/unnamed-chunk-7-1.png)&lt;!-- --&gt;

```r
plot(tab$Год, tab$Каспийское, type="l", lwd = 3, lty = 2)
```

![](05_Graphics_files/figure-html/unnamed-chunk-7-2.png)&lt;!-- --&gt;

```r
plot(tab$Год, tab$Каспийское, type="l", lwd = 1, lty = 3)
```

![](05_Graphics_files/figure-html/unnamed-chunk-7-3.png)&lt;!-- --&gt;

---

# Совмещение графиков

Часто бывает необходимо совместить на одном графике несколько рядов данных. Для этого можно поступить двумя путями: 

1. Нарисовать один ряд данных c помощью функции `plot()`, а затем добавить к нему другие ряды с помощью функций `points()` и `lines()`.

2. Нарисовать пустой график, а затем добавить к нему все ряды данных с помощью функций `points()` и `lines()`.

&gt; При совмещении нескольких рядов данных на одном графике в первом же вызове функции `plot()` необходимо заложить диапазон значений по осям `\(X\)` и `\(Y\)`, охватывающий все ряды данных. В противном случае будет учтен только разброс значений первого ряда данных, и остальные ряды могут не поместиться в поле графика.

Вариант №1 реализуется следующим образом:

```r
plot(tab$Год, 
     tab$Каспийское, 
     pch=20, 
     type="o", 
     ylim = c(0,12), 
     col="red3")

# Добавим теперь на существующий график новый ряд данных, используя функции points() и lines():
points(tab$Год, tab$Карское, pch=20, col="forestgreen")
lines(tab$Год, tab$Карское, pch=20, col="forestgreen")
```

![](05_Graphics_files/figure-html/unnamed-chunk-8-1.png)&lt;!-- --&gt;

&gt; Обратите внимание на то, что если бы мы вызвали еще одну инструкцию `plot()` с новым рядом данных, это привело бы к построению нового графика, а не к добавлению его на существующий.

Теперь рассмотрим второй вариант. Заодно устраним недостаток предыдущего кода, в котором диапазон значений по оси `\(Y\)` указывался вручную.


```r
xrange = range(tab$Год) # вычислим диапазон по оси X
yrange = range(tab$Каспийское, tab$Карское, tab$Азовское) # вычислим диапазон по оси Y

# Построим пустой график, охватывающий полный диапазон данных, и имеющий все необходимые сопроводительные элементы
plot(xrange,
     yrange,
     main="Объем сброса загрязненных сточных вод", 
     xlab="Год", 
     ylab="млрд.куб.м",
     type = "n") # n означает, что ряд данных рисоваться не будет

# Теперь добавим на график ряды данных
points(tab$Год, tab$Каспийское, pch=20, col="red3")
lines(tab$Год, tab$Каспийское, pch=20, col="red3")

points(tab$Год, tab$Карское, pch=20, col="forestgreen")
lines(tab$Год, tab$Карское, pch=20, col="forestgreen")

points(tab$Год, tab$Азовское, pch=20, col="steelblue")
lines(tab$Год, tab$Азовское, pch=20, col="steelblue")
```

![](05_Graphics_files/figure-html/unnamed-chunk-9-1.png)&lt;!-- --&gt;

---

# Функциональные параметры

Графические параметры при построении графиков на самом деле могут быть не константами, а _функцией_ данных. Например, вы можете сказать, что размер точки при построении диаграммы рассеяния должен быть функцией отношения экспорта к импорту, что усилит наглядность отображения:


```r
plot(okr$МетЭкспорт, 
     okr$МетИмпорт, 
     col=rgb(1,0,0,0.5), 
     xlab="Экспорт, млн. долл. США", 
     ylab = "Импорт, млн. долл. США", 
     main = "Экспорт/импорт металлов и изделий из них по ФО РФ (2013 г.)", 
     asp = 1,
     pch = 20, 
     cex = 2+log(sub$МетИмпорт/sub$МетЭкспорт)) # размер кружка зависит от соотношения импорта и экспорта
```

![](05_Graphics_files/figure-html/unnamed-chunk-10-1.png)&lt;!-- --&gt;

---

# Гистограммы

Гистограммы распределения строятся с помощью функции `hist()`. Чтобы изменить ширину кармана (столбца) гистограммы, необходимо задать параметр `breaks =`, а цвет задается в параметре `col`:


```r
hist(sub$ПродЭкспорт)
```

![](05_Graphics_files/figure-html/unnamed-chunk-11-1.png)&lt;!-- --&gt;

```r
# Карманы будут от 0 до 3000 через 100. Заодно добавим цвет:
hist(sub$ПродЭкспорт, breaks = seq(0,3000,100), col="olivedrab3")
```

![](05_Graphics_files/figure-html/unnamed-chunk-11-2.png)&lt;!-- --&gt;

При построении гистограммы (как и любого другого типа графика) вы можете использовать не весь массив данных, а только его подмножество Например, можно посмотреть гистограмму только для субъектов с объемом эспорта менее 300:

```r
hist(sub$ПродЭкспорт[sub$ПродЭкспорт &lt; 300], col = "olivedrab3", breaks = seq(0, 300, 20))
```

![](05_Graphics_files/figure-html/unnamed-chunk-12-1.png)&lt;!-- --&gt;

Наконец, вы можете осуществить преобразование ряда данных перед построением гистограммы. Например, взять логарифм, чтобы проверить,похоже ли распределение на логнормальное:

```r
hist(log(sub$ПродЭкспорт), col = "olivedrab3")
```

![](05_Graphics_files/figure-html/unnamed-chunk-13-1.png)&lt;!-- --&gt;

---

# Столбчатые графики

Столбчатые графики --- __barplot__ --- отображают вектор числовых данных в виде столбиков. Это простейший вид графика (наряду с _dotchart_), который используется для сравнения асболютных величин. Для построения необходимо вызвать функцию `barplot()` и передать ей столбец таблицы:

```r
barplot(okr$ХимЭкспорт)
```

![](05_Graphics_files/figure-html/unnamed-chunk-14-1.png)&lt;!-- --&gt;

```r

# Или даже просто вектор натуральных чисел от -5 до 5:
barplot(-5:5)
```

![](05_Graphics_files/figure-html/unnamed-chunk-14-2.png)&lt;!-- --&gt;

```r

# Если у каждого столбика есть название, 
# нужно передать вектор названий в аргумент names.arg = 
barplot(okr$ХимЭкспорт, names.arg = okr$Регион)
```

![](05_Graphics_files/figure-html/unnamed-chunk-14-3.png)&lt;!-- --&gt;

```r

# при наличии длинных подписей удобнее столбчатую диаграмму разместить горизонтально, используя параметр horiz = TRUE.
barplot(okr$ХимЭкспорт, names.arg = okr$Регион, horiz=TRUE)
```

![](05_Graphics_files/figure-html/unnamed-chunk-14-4.png)&lt;!-- --&gt;

Чтобы развернуть подписи перпендикулярно столбцам, следует использовать параметр `las = `. Справка__R__говорит нам о том, что этот параметр дает следующее поведение подписей:

* 0:  всегда параллельно осям (по умолчанию),
* 1:  всегда горизонтально,
* 2:  всегда перпендикулярно осям,
* 3:  всегда вертикально.

Выберем вариант, при котором подписи всегда горизонтальны:

```r
barplot(okr$ХимЭкспорт, names.arg = okr$Регион, horiz=TRUE, las = 1)
```

![](05_Graphics_files/figure-html/unnamed-chunk-15-1.png)&lt;!-- --&gt;

В данном случае очень массивные названия федеральных не умещаются в пространство графика. Можно было бы вполне убрать словосочетание "федеральный округ". Для этого используем уже знакомую нам `sub()`.

```r
names = sub("федеральный округ", "", okr$Регион) # "" - означает пустая строка
barplot(okr$ХимЭкспорт, names.arg = names, horiz = TRUE, las = 1)
```

![](05_Graphics_files/figure-html/unnamed-chunk-16-1.png)&lt;!-- --&gt;

И снова содержимое не поместилось в поле графика. Проблема в том, что вокруг любого графика резервируются поля ограниченного размера для размещения подписей координат и т.д. Автоматически эти поля не пересчитываются, зарезервировать их --- ваша задача.

Наберите в консоли `?par`. Откроется список всевозможных графических параметров, которые управляют компоновкой и порядком построения графиков. Эти параметры можно установить, вызвав функцию `par()`. Все дальнейшие вызовы инструкций построения графиков будут учитывать установленные параметры Пролистайте страницу справки вниз и найдите параметр `mar = ` --- он отвечает за установку полей в условных единицах. Есть также параметр `mai = `, который позволяет установить поля графика в дюймах. Обратите внимание на то, что означают параметры этой функции:

```r
# mar=c(bottom, left, top, right)
# The default is c(5, 4, 4, 2) + 0.1.
```
Поскольку в нашем примере проблемы возникают в левым полем, необходимо увеличить второй параметр.

```r
margins.default = par("mar") # запишем текущее значение, чтобы восстановить его потом
par(mar = c(5, 10, 4, 2)) # увеличим поле left до 10 условных единиц
barplot(okr$ХимЭкспорт, names.arg = names, horiz=TRUE, las = 1)
```

![](05_Graphics_files/figure-html/unnamed-chunk-18-1.png)&lt;!-- --&gt;

Добавим заголовок с помощью параметра `main = `, а подпись единиц измерения по оси `\(X\)` — с помощью параметра `xlab = `. Поскольку количество параметров функции уже достаточно велико, введем каждый из них с новой строчки, чтобы улучшить читаемость кода:

```r
barplot(okr$ХимЭкспорт, 
        names.arg = names, 
        main = "Экспорт продукции химической промышленности", 
        xlab = "млн долл. США", 
        horiz = TRUE, 
        las = 1)
```

![](05_Graphics_files/figure-html/unnamed-chunk-19-1.png)&lt;!-- --&gt;

```r

# Чтобы увеличить диапазон оси X, можно использовать параметр xlim = c(min, max):
barplot(okr$ХимЭкспорт, 
        names.arg = names, 
        main = "Экспорт продукции химической промышленности", 
        xlab = "млн долл. США", 
        horiz = TRUE, 
        las = 1, 
        xlim = c(0,12000))
```

![](05_Graphics_files/figure-html/unnamed-chunk-19-2.png)&lt;!-- --&gt;

Работа с цветом на столбчатых диаграммах рассмотрена ниже в отдельном разделе.

---

# Круговые (секторные) диаграммы

Круговые диаграммы (англ. _piechart_) строятся с помощью функции `pie()`:

```r
par(mar = c(5, 5, 5, 5)) # установим поля

pie(okr$ХимЭкспорт)
```

![](05_Graphics_files/figure-html/unnamed-chunk-20-1.png)&lt;!-- --&gt;

```r

# вместо номеров можно использовать подписи секторов, добавив второй параметр:
pie(okr$ХимЭкспорт, names)
```

![](05_Graphics_files/figure-html/unnamed-chunk-20-2.png)&lt;!-- --&gt;

```r

# в каждую метку можно добавить процент данного округа в общей массе. Для этого его нужно сначала посчитать:
percentage = 100 * okr$ХимЭкспорт / sum(okr$ХимЭкспорт)

# и округлить до 1 знака после запятой:
percentage = round(percentage, digits = 1)
```

Можно присоединить проценты к названиям округов, добавив обрамляющие скобки. Чтобы функция paste не добавляля пробелы между присоединяемыми строками, необходимо задать параметр sep = , передав ему пустую строку — "":

```r

names2=paste(names, " (", percentage, "%)", sep = "")

# Используем для аннотирования круговых секторов:
pie(okr$ХимЭкспорт, names2)
```

![](05_Graphics_files/figure-html/unnamed-chunk-21-1.png)&lt;!-- --&gt;

```r

# Добавить заголовок можно также с помощью параметра main =
pie(okr$ХимЭкспорт, names2, main = "Доля федеральных округов в экспорте продукции химической промышленности")
```

![](05_Graphics_files/figure-html/unnamed-chunk-21-2.png)&lt;!-- --&gt;

Чтобы перенести часть заголовка на вторую строку, вы можете использовать __управляющий символ__ перевода строки `\n`, вставив его в требуемое место:

```r
pie(okr$ХимЭкспорт, names2, main = "Доля федеральных округов в экспорте \n продукции химической промышленности")
```

![](05_Graphics_files/figure-html/unnamed-chunk-22-1.png)&lt;!-- --&gt;

&gt; Управляющие символы играют большое значение в программировании и используются для управления поведением текстового вывода. Нотация `\n` называется _escape-последовательностью_. Помимо перевода строки, есть и другие полезные [управляющие символы](https://ru.wikipedia.org/wiki/Управляющие_символы). Кстати, именно из-за того, что escape-последовательности начинаются с обратной косой черты (`\`), при указании системных путей в функции `setwd()` всегда следует использовать прямую косую черту (`/`). Например, следующий путь не будет найдет, поскольку он содержит управляющие последовательности `\n` и `\t`: `C:\data\tables\new`.

Наконец, при использовании секторных диаграмм важно уметь менять порядок секторов. По умолчанию сектора откладываются против часовой стрелки начиная с восточного направления. Чтобы сектора откладывались по часовой стрелке с северного направления, следует задать параметр `clockwise = TRUE`.

```r
pie(okr$ХимЭкспорт, 
    names2, 
    main = "Доля федеральных округов в экспорте \n продукции химической промышленности", 
    clockwise = TRUE)
```

![](05_Graphics_files/figure-html/unnamed-chunk-23-1.png)&lt;!-- --&gt;

Работа с цветом на круговых диаграммах рассмотрена ниже в отдельном разделе.

---

# Цвет и прозрачность

Цвет --- одно из основных графических средств, используемых на графиках и диаграммах, поэтому данная тема рассмотрена более подробно в отдельном разделе. Определить цвет можно различными способами. Во-первых, в __R__ есть палитра предопределенных цветов, которые можно выбирать по их [названию](http://research.stowers-institute.org/efg/R/Color/Chart/ColorChart.pdf)).

Список называний цветов можно посмотреть, вызвав функцию `colors()`:

```r
head(colors())
## [1] "white"         "aliceblue"     "antiquewhite"  "antiquewhite1"
## [5] "antiquewhite2" "antiquewhite3"
```

Основной цвет любого графика или диграмма задается параметром `col = `. Это цвет (или цвета) с помощью которых будут отображаться данные. Попробуем изменить цвет графика с серого на пастельно-синий:

```r
par(mar = c(5, 10, 4, 2)) # увеличим поле left до 10 условных единиц
barplot(okr$ХимЭкспорт, 
        names.arg = names, 
        main = "Экспорт продукции химической промышленности", 
        xlab = "млн долл. США", 
        horiz = TRUE, 
        las = 1, 
        xlim = c(0,12000), 
        col = "steelblue")
```

![](05_Graphics_files/figure-html/unnamed-chunk-25-1.png)&lt;!-- --&gt;
Помимо этого вы можете задать цвет с помощью цветовых компонент в различных пространствах. Для этого вы должны быть знакомы с основами теории цвета (посмотрите презентацию [UsingColorInR.pdf](http://research.stowers-institute.org/efg/Report/UsingColorInR.pdf). Например, фиолетовый цвет в пространстве [RGB](https://ru.wikipedia.org/wiki/RGB) можно задать с помощью функции `rgb()`, смешав синюю и красную компоненты:

```r
violet = rgb(0.4, 0, 0.6)
barplot(okr$ХимЭкспорт, 
        names.arg = names, 
        main = "Экспорт продукции химической промышленности", 
        xlab = "млн долл. США", 
        horiz = TRUE, 
        las = 1, 
        xlim = c(0,12000), 
        col = violet)
```

![](05_Graphics_files/figure-html/unnamed-chunk-26-1.png)&lt;!-- --&gt;

Чтобы сделать цвет __полупрозрачным__, есть две возможности: 

* При создании нового цвета --- передать в функцию `rgb()` дополнительный параметр `alpha = `, который задает долю прозрачности в диапазоне от 0 до 1.
* При модификации существующего цвета --- вызвать функцию `adjustcolor()` с параметром `alpha = `

Например:

```r
violet.transp = adjustcolor(violet, alpha = 0.5)
barplot(okr$ХимЭкспорт, 
        names.arg = names, 
        main = "Экспорт продукции химической промышленности", 
        xlab = "млн долл. США", 
        horiz = TRUE, 
        las = 1, 
        xlim = c(0,12000), 
        col = violet.transp)
```

![](05_Graphics_files/figure-html/unnamed-chunk-27-1.png)&lt;!-- --&gt;

```r

green.transp = rgb(0, 1, 0, 0.5) # появился четвертый параметр
barplot(okr$ХимЭкспорт, 
        names.arg = names, 
        main = "Экспорт продукции химической промышленности", 
        xlab = "млн долл. США", 
        horiz = TRUE, 
        las = 1, 
        xlim = c(0,12000), 
        col = green.transp)
```

![](05_Graphics_files/figure-html/unnamed-chunk-27-2.png)&lt;!-- --&gt;

&gt; Функция `adjustcolor()` позволяет модифицировать все компоненты цвета, не только прозрачность. 

На графике типа _barplot_ вы имеете фактически несколько переменных, которые представлены столбиками. А это означает что для них можно использовать различные цвета. Вы можете передать в параметр `col = ` вектор из цветов, соответствующих столбикам:

```r
colors = c("red", "green", "blue", "orange", "yellow", "pink", "white","black")

barplot(okr$ХимЭкспорт, 
        names.arg = names, 
        main = "Экспорт продукции химической промышленности", 
        xlab = "млн долл. США", 
        horiz = TRUE, 
        las = 1, 
        xlim = c(0,12000), 
        col = colors)
```

![](05_Graphics_files/figure-html/unnamed-chunk-28-1.png)&lt;!-- --&gt;

На самом деле, такой винегрет из цветов на столбчатых диаграммах использовать не принято. Но вы должны понимать, что при необходимости можно поменять цвет отдельно выбранных столбиков. Например, мы можем показать красным цветом Wентральный и Приволжский округа, которые являются лидерами по экспорту продукции химической промышленности:

```r
colors = rep("gray", 8) # сделаем 8 серых цветов
colors[2] = "red"
colors[7] = "red"
barplot(okr$ХимЭкспорт, 
        names.arg = names, 
        main = "Экспорт продукции химической промышленности", 
        xlab = "млн долл. США", 
        horiz = TRUE, 
        las = 1, 
        xlim = c(0,12000), 
        col = colors)
```

![](05_Graphics_files/figure-html/unnamed-chunk-29-1.png)&lt;!-- --&gt;

Еще одна интересная особенность использования цвета заключается в том, что количество указанных цветом может не совпадать с количеством рядов данных. Вы можете указать 2 или 3 цвета, и они будут циклически повторяться при визуализации данных:

```r
colors=c("gray","steelblue")
barplot(okr$ХимЭкспорт, 
        names.arg = names, 
        main = "Экспорт продукции химической промышленности", 
        xlab = "млн долл. США", 
        horiz =TRUE, 
        las = 1, 
        xlim = c(0, 12000), 
        col = colors)
```

![](05_Graphics_files/figure-html/unnamed-chunk-30-1.png)&lt;!-- --&gt;

Наконец, вещь, которой совершенно необходимо уметь пользоваться при работе с цветом в __R__ --- это цветовые палитры. Палитры чрезвычайно удобны, когда необходимо сгенерировать множество цветов, зная лишь основные оттенки. Для этого нужно создать палитру, используя функцию `colorRampPalette()`:

```r
# задаем 2 опорных цвета: черный  белый
palet=colorRampPalette(c("black","white")) 

# и автоматически генерируем 8 цветов между ними:
colors=palet(8)

# используем их для отображения:
barplot(okr$ХимЭкспорт, 
        names.arg = names, 
        main = "Экспорт продукции химической промышленности", 
        xlab = "млн долл. США", 
        horiz = TRUE, 
        las = 1, 
        xlim = c(0, 12000), 
        col= colors)
```

![](05_Graphics_files/figure-html/unnamed-chunk-31-1.png)&lt;!-- --&gt;

```r

# вы можете включить в палитру произвольное количество цветов:
palet=colorRampPalette(c("steelblue","white","purple4")) 
colors=palet(8)
barplot(okr$ХимЭкспорт, 
        names.arg = names, 
        main = "Экспорт продукции химической промышленности", 
        xlab = "млн долл. США", 
        horiz=TRUE, 
        las = 1, 
        xlim = c(0, 12000), 
        col= colors)
```

![](05_Graphics_files/figure-html/unnamed-chunk-31-2.png)&lt;!-- --&gt;

В __R__ cуществует множество стандартных палитр, их список можно найти в справке и документации. Наиболее полезные из них:

* `colors()`
* `gray()`
* `rainbow()`
* `heat.colors()`
* `topo.colors()`
* `terrain.colors()`

Напрмер, вы можете изменить цвета диаграммы, взяв их из одной из палитр или выбрав случайным образом из полной палитры цветов, используя функцию `sample()`:

```r
pie(okr$ХимЭкспорт, names2, main = "Доля федеральных округов в экспорте \n продукции химической промышленности", col=rainbow(length(names2)))
```

![](05_Graphics_files/figure-html/unnamed-chunk-32-1.png)&lt;!-- --&gt;

```r
pie(okr$ХимЭкспорт, names2, main = "Доля федеральных округов в экспорте \n продукции химической промышленности", col=sample(colors(),5))
```

![](05_Graphics_files/figure-html/unnamed-chunk-32-2.png)&lt;!-- --&gt;

Более богатый набор палитр можно найти в библиотеке `RColorBrewer`, которая представляет собой интерпретацию палитр, доступных на сайте [colorbrewer2.org](http://colorbrewer2.org/)


```r
library(RColorBrewer) # Откроем библиотеку RColorBrewer:
display.brewer.all() # Посмотрим, какие в ней имеются палитры
```

![](05_Graphics_files/figure-html/unnamed-chunk-34-1.png)&lt;!-- --&gt;


К каждой из этих палитр можно обратиться по названию с помощью функции `brewer.pal()`. Поскольку нам необходимы цвета для категориальных данных, следует использовать палитры из средней части (_Set3 - Accent_)


```r
# выберем цвета из палитры Set2 по количеству секторов в круге:
colors = brewer.pal(length(names2),"Set1")

# И используем их при визуализации
par(mar = c(5, 5, 5, 5)) # установим поля
pie(okr$ХимЭкспорт, names2, main = "Доля федеральных округов в экспорте \n продукции химической промышленности", col=colors)
```

![](05_Graphics_files/figure-html/unnamed-chunk-36-1.png)&lt;!-- --&gt;

```r

# Попробуем палитру Accent:
pie(okr$ХимЭкспорт, names2, main = "Доля федеральных округов в экспорте \n продукции химической промышленности", col=brewer.pal(length(names2),"Accent"))
```

![](05_Graphics_files/figure-html/unnamed-chunk-36-2.png)&lt;!-- --&gt;

---

# Графические параметры

Изменять __размеры элементов графика__ можно независимо друг от друга, используя следующие параметры:

* `cex` --- общий масштаб элементов на графике
* `cex.axis` --- масштаб подписей координат на оси
* `cex.lab` ---	масштаб подписей названий осей
* `cex.main` ---	масштаб заголовка графика
* `cex.sub` ---	масштаб подзаголовка графика
* `cex.names` --- масштаб подписей факторов (для некоторых типов диаграмм)

Например:

```r
plot(tab$Год, 
     tab$Каспийское, 
     pch=20, 
     type="o", 
     ylim = c(0,12), 
     col="red3", 
     main="Объем сброса загрязненных сточных вод", 
     xlab="Год", 
     ylab="млрд.куб.м",
     cex.axis=0.8, 
     cex.lab=0.7, 
     cex.main=0.9, 
     cex = 0.8)

points(tab$Год, tab$Карское, pch=20, col="forestgreen",cex = 0.8)
lines(tab$Год, tab$Карское, pch=20, col="forestgreen")

points(tab$Год, tab$Азовское, pch=20, col="steelblue",cex = 0.8)
lines(tab$Год, tab$Азовское, pch=20, col="steelblue")
```

![](05_Graphics_files/figure-html/unnamed-chunk-37-1.png)&lt;!-- --&gt;

Аналогично происходит тонкая настройка __цвета__:

* `col`       цвет графика
* `col.axis`	цвет подписей координат
* `col.lab`   цвет названий осей
* `col.main`	цвет заголовка
* `col.sub`   цвет подзаголовка
* `fg`        цвет элементов переднего плана (оси, рамка и т.д.)
* `bg`        цвет фона графика (background)


```r
plot(tab$Год, 
     tab$Каспийское, 
     pch=20, 
     type="o", 
     ylim = c(0,12), 
     col="red3", 
     main="Объем сброса загрязненных сточных вод", 
     xlab="Год", 
     ylab="млрд.куб.м",
     cex.axis=0.8, 
     cex.lab=0.7, 
     cex.main=0.9, 
     col.lab = "grey50", 
     fg = "grey40")
points(tab$Год, tab$Карское, pch=20, col="forestgreen")
lines(tab$Год, tab$Карское, pch=20, col="forestgreen")
points(tab$Год, tab$Азовское, pch=20, col="steelblue")
lines(tab$Год, tab$Азовское, pch=20, col="steelblue")
```

![](05_Graphics_files/figure-html/plotcolors-1.png)&lt;!-- --&gt;

---

# Разметка осей, рамка, сетка координат и произвольные линии {#axes}

По умолчанию __R__ подбирает оптимальный с точки зрения него шаг разметки осей, в зависимости от разброса значений по осям `\(X\)` и `\(Y\)`, а также размеров графического устройства, на котором производится рисование. Изменяя размер окна прорисовки, вы получите различную разметку осей.

В то же время, часто возникает желание (или необходимость) самостоятельно управлять шагом разметки сетки. Для этого необходимо:

1. Вызвать функцию `plot()`, передав ей дополнительно параметр `axes = FALSE` (убирает при рисовании обе оси) или один из параметров `xaxt="n"` / `yaxt="n"` (убирают оси `\(X\)` и `\(Y\)` соответственно)
2. Вызвать столько раз функцию `axis()`, сколько вы хотите нарисовать осей, передав ей параметры для рисования каждой оси.

Функция `axis()` принимает следующие параметры:

* `side` --- сторона графика, на которой будет нарисована ось (`1=bottom`, `2=left`, `3=top`, `4=right`)
* `at` --- вектор значений, в которых должны быть нарисованы метки оси
* `labels` --- вектор подписей, которые будут нарисованы в местоположениях, указанных в параметре `at`. Этот параметр можно пропустить, если подписи совпадают с местоположениями меток
* `pos` --- координата, вдоль которой будет нарисована ось 
* `lty` --- тип линии
* `col` --- цвет линии и меток
* `las` --- расположение подписей параллельно ($0$) или перпендикулярно ($2$) оси
* `tck` --- длина метки относительно размера графика. Отрицательные значения дают метки, выходящие за пределы графика. положительные — внутрь графика. `\(0\)` убирает метки, `\(1\)` рисует линии сетки.

При ручном построении осей полезно сразу же нарисовать рамку вокруг графика, используя функцию `box()`.

Например:

```r
plot(tab$Год, 
     tab$Каспийское,
     type = "l",
     axes = FALSE)

axis(side = 1, 
     at = seq(min(tab$Год), max(tab$Год), 1),
     tck = -0.02,
     labels = FALSE) # разметим ось X через 1 год, но рисовать подписи не будем

axis(side = 1, 
     at = seq(min(tab$Год), max(tab$Год), 3), # а подписи расставим через 3 года
     tck = 0) # но рисовать метки не будем

# разметим ось Y через 1 млрд куб. м., округлив предварительно минимальное и максимальное значение до ближайшего целого снизу и сверху соответственно
axis(side = 2, 
     at = seq(floor(min(tab$Каспийское)), ceiling(max(tab$Каспийское)), 1),
     tck = -0.02) 

box() # добавим рамку для красоты
```

![](05_Graphics_files/figure-html/manual-1.png)&lt;!-- --&gt;

Для размещения сетки координат существует функция `grid(nx = NULL, ny = nx, col = "lightgray", lty = "dotted", lwd = par("lwd"), equilogs = TRUE)`. Как видно из набора ее параметров, сетка определяется количеством линий в горизонтальном и вертикальном направлении. Это не всегда бывает удобно, поскольку как правило мы хотим задать шаг сетки конкретной величины. По умолчанию, однако, линии сетки выбираются автоматически, как и метки:

```r
plot(tab$Год, 
     tab$Каспийское,
     type = "l",
     col = "red")
grid()
```

![](05_Graphics_files/figure-html/unnamed-chunk-38-1.png)&lt;!-- --&gt;

Вы, разумеется, можете поменять их количество, однако __R__ не будет за вас согласовывать шаг сетки и шаг меток осей, поскольку метки генерируются на стадии рисования `plot()` или `axis()` и не запоминаются.

```r
plot(tab$Год, 
     tab$Каспийское,
    type = "l",
    col = "red")
grid(10, 5)
```

![](05_Graphics_files/figure-html/unnamed-chunk-39-1.png)&lt;!-- --&gt;

Функция `grid()` на самом деле является оберткой функции `abline()`, которая позволяет рисовать произвольные линии на графике. Данна функция предоставляет следующие возможности построения линий и серий линий:

* `a, b` --- коэффициенты уравнения `\(y = ax + b\)`. Таким образом можно определить только одну линию.
* `coef` --- принимает вектор из двух значений, которые интерпретируются как `a` и `b`. То есть, это альтернативная форма записи предыдущего случая.
* `h` --- значение (значения) координат `\(y\)` для горизонтальной линии (серии горизонтальных линий). То есть, вы можете передать в этот параметр как одиночное значение, так и вектор значений. В зависимости это этого нарисуется одна горизонтальная линия или серия горизонтальных линий.
* `v` --- значение (значения) координат `\(x\)` для вертикальной линии (серии веритикальных линий). Работает аналогично параметру `h`.
* `reg` --- сюда можно передать объект, обладающий методом `coef()`. Этот способ можно использовать для рисования линий регрессии.

Предположим теперь, что вы хотите нарисовать сетку с шагом в 1 год по горизонтальной оси и шагом 1 млрд. куб. м по оси вертикальной. При этом вы также хотите, чтобы линии сетки располагались _под_ графиком, а не поверх его. Также необходимо выделить особым цветом значение в 10 млрд м$^3$ по оси `\(Y\)`. Для этого выполним следующую последовательность действий:

```r
plot(tab$Год, 
     tab$Каспийское, 
     type="n") # режим 'n' позволяет ничего не рисовать, но заложить поле графика в соответствии с данными, указанными в параметрах x и y

# Вычисляем линии сетки
xlines = seq(min(tab$Год), max(tab$Год), 1)
ylines = seq(ceiling(min(tab$Каспийское)),
              floor(max(tab$Каспийское)), 1)

# Рисуем линии сетки
abline(h = ylines, v = xlines, col = "lightgray")

# Рисуем график
lines(tab$Год, 
     tab$Каспийское, 
     col="red3")
points(tab$Год, 
     tab$Каспийское,
     pch = 20,
     col="red3")

# Выделяем значение 10 по оси Y:
abline(h = 10, col = "blue", lwd = 2)

# Рисуем дополнительно рамку, т.к. сетку координат мы рисовали после графика
box()
```

![](05_Graphics_files/figure-html/manualaxes-1.png)&lt;!-- --&gt;

---

# Аннотации данных (текст на графике)

Аннотации данных добавляются на график с помощью функции `text()`. В качестве  трех обязательных аргументов ей необходимо передать координаты точек размещения текста, и вектор подписей. Также полезным будет указать параметр `pos=`, отвечающий за размещение аннотации относительно точки. Значения `pos`, равные 1, 2, 3 и 4, соответствуют размещению снизу, слева, сверху и справа от точки:

```r
text(tab$Год, 
     tab$Каспийское,
     labels = tab$Каспийское,
     cex = 0.75,
     pos = 3)
```
![](05_Graphics_files/figure-html/unnamed-chunk-40-1.png)&lt;!-- --&gt;

&gt; К сожалению, стандартный механизм размещения аннотаций пакета `graphics` не обладает возможностью устранения конфликтов подписей. Однако это возможно для графиков, построенных с помощью библиотек [lattice](https://cran.r-project.org/web/packages/lattice/index.html) и [ggplot2](https://cran.r-project.org/web/packages/ggplot2/index.html). Для этого можно воспользоваться пакетом [directlabels](https://cran.r-project.org/web/packages/directlabels/index.html) или  [ggrepel](https://cran.r-project.org/web/packages/ggrepel/index.html).

---

## Легенда

Легенда к графику размещается с помощью функции `legend()`. Эта функция принимает несколько аргументов, включая: местоположение, заголовок, названия элементов, графические параметры. Местоположение может быть задано координатами `\((x,y)\)` в системе координат графика, но удобнее пользоваться следующими предопределенными константами: `"bottomright"`, `"bottom"`, `"bottomleft"`, `"left"`, `"topleft"`, `"top"`, `"topright"`, `"right"`, `"center"`. 

Чтобы в легенде появились точки, необходимо задать параметр `pch=`. Для линейной легенды, следует задать, соответственно, параметр `lty =` и/или `lwd =`. Каждый из этих параметров должен быть вектором по количеству элементов легенды:


```r
par(mar = margins.default)

# Найдем ограничивающий прямоугольник вокруг всех рядов данных
xrange = range(tab$Год)
yrange = range(tab$Каспийское, tab$Карское, tab$Азовское)

# Построим пустой график с разметкой осей и всеми заголовками
plot(xrange, 
     yrange, 
     type="n", 
     main="Объем сброса загрязненных сточных вод", 
     xlab="Год", 
     ylab="млрд.куб.м",
     cex.axis=0.8, 
     cex.lab=0.7, 
     cex.main=0.9, 
     col.lab = "grey50", 
     fg = "grey40")

# Добавим на график сетку координат
grid()

# Добавим на график данные
points(tab$Год, tab$Каспийское, pch=20, col="red3")
lines(tab$Год, tab$Каспийское, pch=20, col="red3")

points(tab$Год, tab$Карское, pch=20, col="forestgreen")
lines(tab$Год, tab$Карское, pch=20, col="forestgreen")

points(tab$Год, tab$Азовское, pch=20, col="steelblue")
lines(tab$Год, tab$Азовское, pch=20, col="steelblue")

# Определим положение, названия и цвета:
main = "Море"
location = "topright"
labels = c("Каспийское", "Карское", "Азовское")
colors = c("red3", "forestgreen", "steelblue")

# Если цвет передать в параметр fill, то по умолчанию
# нарисуются цветовые плашки:
legend(location, labels, title = main, fill=colors)
```

![](05_Graphics_files/figure-html/caspianlegend-1.png)&lt;!-- --&gt;


```r
pts = c(20, 20, 20) # каждый элемент показывается точкой типа 20
lns = c(1, 1, 1) # каждый элемент показывается линией толщиной 1

# теперь посмотрим на легенду (она нарисуется поверх старой)
legend(location, labels, title = main, col = colors, pch = pts, lwd = lns)
```

![](05_Graphics_files/figure-html/unnamed-chunk-41-1.png)&lt;!-- --&gt;

Более подробно с разнообразными опциями размещения легенды на графике вы можете познакомиться, набрав в консоли команду `?legend`.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
